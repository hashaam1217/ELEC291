0000              1   ; vim:foldmethod=marker:foldlevel=0
0000              2   
0000              3   ; DOCS {{{
0000              4   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              5   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P1.7 using
0000              6   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              7   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to
0000              8   ; zero if the 'CLEAR' push button connected to P1.5 is pressed.
                 10   $LIST
0000             12   
0000             13   ;  N76E003 pinout:
0000             14   ;                               -------
0000             15   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             16   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             17   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             18   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             19   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             20   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             21   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             22   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             23   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             24   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             25   ;                               -------
0000             26   ; 1     0.5 - BUTTON 1
0000             27   ; 2     USED
0000             28   ; 3     USED
0000             29   ; 4     RESET BUTTON
0000             30   ; 5     3.0 - BUTTON 2
0000             31   ; 6     SPEAKER
0000             32   ; 7     GND
0000             33   ; 8     1.6 - BUTTON 4
0000             34   ; 9     VDD
0000             35   ; 10    1.5 - BUTTON 5
0000             36   ;
0000             37   ; 11    UNUSED
0000             38   ; 12    USED
0000             39   ; 13    USED
0000             40   ; 14    1.1 - BUTTON 3
0000             41   ; 15    USED
0000             42   ; 16    UNUSED
0000             43   ; 17    UNUSED
0000             44   ; 18    UNUSED
0000             45   ; 19    UNUSED
0000             46   ; 20    UNUSED
0000             47   
0000             48   ; Button mapping:
0000             49   ; Button 1 to 5, starting from  left to right
0000             50   ; BUTTON 1 - HOUR
0000             51   ; BUTTON 2 - MIN
0000             52   ; BUTTON 3 - SEC
0000             53   ; BUTTON 4 - TIME SET
0000             54   ; BUTTON 5 - ALARM
0000             55   
0000             56   ; CONFIG {{{
0000             57   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             58   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             59   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             60   TIMER2_RATE   EQU 500     ; 1000Hz, for a timer tick of 1ms
0000             61   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             62   
0000             63   UPDOWN        equ P1.6
0000             64   SOUND_OUT     equ P1.7
0000             65   BUTTON1       equ P0.5
0000             66   BUTTON2       equ P3.0
0000             67   BUTTON3       equ P1.1
0000             68   BUTTON4       equ P1.6
0000             69   BUTTON5       equ P1.5
0000             70   
0000             71   ; Reset vector
0000             72   org 0x0000
0000 02016A      73       ljmp main
0003             74   
0003             75   ; External interrupt 0 vector (not used in this code)
0003             76   org 0x0003
0003 32          77            reti
0004             78   
0004             79   ; Timer/Counter 0 overflow interrupt vector
000B             80   org 0x000B
000B 02010A      81            ljmp Timer0_ISR
000E             82   
000E             83   ; External interrupt 1 vector (not used in this code)
0013             84   org 0x0013
0013 32          85            reti
0014             86   
0014             87   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             88   org 0x001B
001B 32          89            reti
001C             90   
001C             91   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             92   org 0x0023
0023 32          93            reti
0024             94   
0024             95   ; Timer/Counter 2 overflow interrupt vector
002B             96   org 0x002B
002B 020134      97            ljmp Timer2_ISR
002E             98   
002E             99   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030            100   dseg at 0x30
0030            101   Count1ms:     ds 2 ; Used to determine when half second has passed
0032            102   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            103   min_counter:  ds 1
0034            104   hour_counter: ds 1
0035            105   day_state:    ds 1
0036            106   
0036            107   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0036            108   ; instructions with these variables.  This is how you define a 1-bit variable:
0000            109   bseg
0000            110   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001            111   
002E            112   cseg
002E            113   ; These 'equ' must match the hardware wiring
002E            114   LCD_RS equ P1.3
002E            115   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E            116   LCD_E  equ P1.4
002E            117   LCD_D4 equ P0.0
002E            118   LCD_D5 equ P0.1
002E            119   LCD_D6 equ P0.2
002E            120   LCD_D7 equ P0.3
002E            121   
                123   	$LIST
00E2            125   
00E2            126   ;                     1234567890123456    <- This helps determine the location of the counter
00E2 78783A78   127   Initial_Message:  db 'xx:xx:xx xx', 0
     783A7878
     20787800
00EE            128   ;                    '00:00:00 AM '
00EE 414D00     129   AM: db 'AM', 0
00F1 504D00     130   PM: db 'PM', 0
00F4            131   
00F4            132   ;---------------------------------;
00F4            133   ; Routine to initialize the ISR   ;
00F4            134   ; for timer 0                     ;
00F4            135   ;---------------------------------;
00F4            136   Timer0_Init:
00F4 438E08     137            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
00F7 E589       138            mov a, TMOD
00F9 54F0       139            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
00FB 4401       140            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
00FD F589       141            mov TMOD, a
00FF 758CF0     142            mov TH0, #high(TIMER0_RELOAD)
0102 758A2C     143            mov TL0, #low(TIMER0_RELOAD)
0105            144            ; Enable the timer and interrupts
0105 D2A9       145       setb ET0  ; Enable timer 0 interrupt
0107 D28C       146       setb TR0  ; Start timer 0
0109 22         147            ret
010A            148   
010A            149   ;---------------------------------;
010A            150   ; ISR for timer 0.  Set to execute;
010A            151   ; every 1/4096Hz to generate a    ;
010A            152   ; 2048 Hz wave at pin SOUND_OUT   ;
010A            153   ;---------------------------------;
010A            154   Timer0_ISR:
010A            155            ;clr TF0  ; According to the data sheet this is done for us already.
010A            156            ; Timer 0 doesn't have 16-bit auto-reload, so
010A C28C       157            clr TR0
010C 758CF0     158            mov TH0, #high(TIMER0_RELOAD)
010F 758A2C     159            mov TL0, #low(TIMER0_RELOAD)
0112 D28C       160            setb TR0
0114 B297       161            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
0116 32         162            reti
0117            163   
0117            164   ;---------------------------------;
0117            165   ; Routine to initialize the ISR   ;
0117            166   ; for timer 2                     ;
0117            167   ;---------------------------------;
0117            168   Timer2_Init:
0117 75C800     169            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
011A 75CD7E     170            mov TH2, #high(TIMER2_RELOAD)
011D 75CC50     171            mov TL2, #low(TIMER2_RELOAD)
0120            172            ; Set the reload value
0120 43C980     173            orl T2MOD, #0x80 ; Enable timer 2 autoreload
0123 75CB7E     174            mov RCMP2H, #high(TIMER2_RELOAD)
0126 75CA50     175            mov RCMP2L, #low(TIMER2_RELOAD)
0129            176            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0129 E4         177            clr a
012A F530       178            mov Count1ms+0, a
012C F531       179            mov Count1ms+1, a
012E            180            ; Enable the timer and interrupts
012E 439B80     181            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0131 D2CA       182       setb TR2  ; Enable timer 2
0133 22         183            ret
0134            184   
0134            185   ;---------------------------------;
0134            186   ; ISR for timer 2                 ;
0134            187   ;---------------------------------;
0134            188   Timer2_ISR:
0134 C2CF       189            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0136 B284       190            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0138            191   
0138            192            ; The two registers used in the ISR must be saved in the stack
0138 C0E0       193            push acc
013A C0D0       194            push psw
013C            195   
013C            196            ; Increment the 16-bit one mili second counter
013C 0530       197            inc Count1ms+0    ; Increment the low 8-bits first
013E E530       198            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0140 7002       199            jnz Inc_Done
0142 0531       200            inc Count1ms+1
0144            201   
0144            202   Inc_Done:
0144            203            ; Check if half second has passed
0144 E530       204            mov a, Count1ms+0
0146 B4F41C     205            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0149 E531       206            mov a, Count1ms+1
014B B40117     207            cjne a, #high(500), Timer2_ISR_done
014E            208   
014E            209            ; 500 milliseconds have passed.  Set a flag so the main program knows
014E D200       210            setb half_seconds_flag ; Let the main program know half second had passed
0150 B28C       211            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0152            212            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0152 E4         213            clr a
0153 F530       214            mov Count1ms+0, a
0155 F531       215            mov Count1ms+1, a
0157            216            ; Increment the BCD counter
0157 E532       217            mov a, BCD_counter
0159 309604     218            jnb UPDOWN, Timer2_ISR_decrement
015C 2401       219            add a, #0x01
015E 8002       220            sjmp Timer2_ISR_da
0160            221   Timer2_ISR_decrement:
0160 2499       222            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0162            223   Timer2_ISR_da:
0162 D4         224            da a ; Decimal adjust instruction.  Check datasheet for more details!
0163 F532       225            mov BCD_counter, a
0165            226   
0165            227   
0165            228   Timer2_ISR_done:
0165 D0D0       229            pop psw
0167 D0E0       230            pop acc
0169 32         231            reti
016A            232   ;}}}
016A            233   ;---------------------------------;
016A            234   ; Main program. Includes hardware ;
016A            235   ; initialization and 'forever'    ;
016A            236   ; loop.                           ;
016A            237   ;---------------------------------;
016A            238   ; MAIN LOOP + buttons {{{
016A            239   main:
016A            240            ; Initialization
016A 75817F     241       mov SP, #0x7F
016D 75B100     242       mov P0M1, #0x00
0170 75B200     243       mov P0M2, #0x00
0173 75B300     244       mov P1M1, #0x00
0176 75B400     245       mov P1M2, #0x00
0179 75AD00     246       mov P3M2, #0x00
017C 75AD00     247       mov P3M2, #0x00
017F            248   
017F 1200F4     249       lcall Timer0_Init
0182 120117     250       lcall Timer2_Init
0185 D2AF       251       setb EA   ; Enable Global interrupts
0187 120087     252       lcall LCD_4BIT
018A            253       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
018A C0E0       254            push acc
018C 7401       254            mov a, #1
018E 14         254            dec a
018F 1200C7     254            lcall ?Set_Cursor_1 ; Select column and row
0192 D0E0       254            pop acc
0194 C083       255            push dph
0196 C082       255            push dpl
0198 C0E0       255            push acc
019A 9000E2     255            mov dptr, #Initial_Message
019D 1200BA     255            lcall ?Send_Constant_String
01A0 D0E0       255            pop acc
01A2 D082       255            pop dpl
01A4 D083       255            pop dph
01A6 D200       256       setb half_seconds_flag
01A8 753200     257            mov BCD_counter, #0x00
01AB 753300     258       mov min_counter, #0x00
01AE 753400     259       mov hour_counter, #0x00
01B1 753500     260       mov day_state, #0 ; To configure AM/PM
01B4            261   
01B4            262            ; After initialization the program stays in this 'forever' loop
01B4            263   loop:
01B4 20850F     264            jb BUTTON1, buttonjump2 ; if the 'CLEAR' button is not pressed skip
01B7 C002       265            push AR2
01B9 7A32       265            mov R2, #50
01BB 120038     265            lcall ?Wait_Milli_Seconds
01BE D002       265            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01C0 208503     266            jb BUTTON1, buttonjump2; if the 'CLEAR' button is not pressed skip
01C3 3085FD     267            jnb BUTTON1, $          ; Wait for button release.  The '$' means: jump to same instruction.
01C6            268   
01C6            269   buttonjump2:
01C6 20B00F     270            jb BUTTON2, buttonjump3 ; if the 'CLEAR' button is not pressed skip
01C9 C002       271            push AR2
01CB 7A32       271            mov R2, #50
01CD 120038     271            lcall ?Wait_Milli_Seconds
01D0 D002       271            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01D2 20B003     272            jb BUTTON2, buttonjump3; if the 'CLEAR' button is not pressed skip
01D5 30B0FD     273            jnb BUTTON2, $          ; Wait for button release.  The '$' means: jump to same instruction.
01D8            274   buttonjump3:
01D8 20910F     275            jb BUTTON3, buttonjump4 ; if the 'CLEAR' button is not pressed skip
01DB C002       276            push AR2
01DD 7A32       276            mov R2, #50
01DF 120038     276            lcall ?Wait_Milli_Seconds
01E2 D002       276            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01E4 209103     277            jb BUTTON3, buttonjump4; if the 'CLEAR' button is not pressed skip
01E7 3091FD     278            jnb BUTTON3, $          ; Wait for button release.  The '$' means: jump to same instruction.
01EA            279   buttonjump4:
01EA 20960F     280            jb BUTTON4, buttonjump5 ; if the 'CLEAR' button is not pressed skip
01ED C002       281            push AR2
01EF 7A32       281            mov R2, #50
01F1 120038     281            lcall ?Wait_Milli_Seconds
01F4 D002       281            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01F6 209603     282            jb BUTTON4, buttonjump5; if the 'CLEAR' button is not pressed skip
01F9 3096FD     283            jnb BUTTON4, $          ; Wait for button release.  The '$' means: jump to same instruction.
01FC            284   buttonjump5:
01FC 20951C     285            jb BUTTON5, loop_a ; if the 'CLEAR' button is not pressed skip
01FF C002       286            push AR2
0201 7A32       286            mov R2, #50
0203 120038     286            lcall ?Wait_Milli_Seconds
0206 D002       286            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0208 209510     287            jb BUTTON5, loop_a  ; if the 'CLEAR' button is not pressed skip
020B 3095FD     288            jnb BUTTON5, $          ; Wait for button release.  The '$' means: jump to same instruction.
020E            289   
020E            290   clear:
020E            291   
020E            292   
020E            293   
020E            294   
020E            295            ; A valid press of the 'CLEAR' button has been detected, reset the BCD counter.
020E            296            ; But first stop timer 2 and reset the milli-seconds counter, to resync everything.
020E C2CA       297            clr TR2                 ; Stop timer 2
0210 E4         298            clr a
0211 F530       299            mov Count1ms+0, a
0213 F531       300            mov Count1ms+1, a
0215            301            ; Now clear the BCD counter
0215 F532       302            mov BCD_counter, a
0217 D2CA       303            setb TR2                ; Start timer 2
0219 8003       304            sjmp loop_b             ; Display the new value
021B            305   
021B            306   ;}}}
021B            307   loop_a:
021B 300096     308            jnb half_seconds_flag, loop
021E            309   ; LOOP B Display Timer {{{
021E            310   loop_b:
021E            311       ;Using this to print the time
021E C200       312       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
0220            313   ;        Set_Cursor(1, 14)     ; the place in the LCD where we want the BCD counter value
0220            314   ;        Display_BCD(BCD_counter) ; This macro is also in 'LCD_4bit.inc'
0220            315   
0220 AC32       316       mov R4, BCD_counter
0222 BC0605     317       CJNE R4, #6, secondskip
0225 753200     318       mov BCD_counter, #0x00
0228 0533       319       inc min_counter
022A            320   secondskip:
022A C0E0       321            push acc
022C 7407       321            mov a, #7
022E 14         321            dec a
022F 1200C7     321            lcall ?Set_Cursor_1 ; Select column and row
0232 D0E0       321            pop acc
0234 C000       322            push ar0
0236 A832       322            mov r0, BCD_counter
0238 1200CC     322            lcall ?Display_BCD
023B D000       322            pop ar0
023D            323   
023D AC33       324       mov R4, min_counter
023F BC0205     325       CJNE R4, #2, minskip
0242 753300     326       mov min_counter, #0x00
0245 0534       327       inc hour_counter
0247            328   minskip:
0247 C0E0       329            push acc
0249 7404       329            mov a, #4
024B 14         329            dec a
024C 1200C7     329            lcall ?Set_Cursor_1 ; Select column and row
024F D0E0       329            pop acc
0251 C000       330            push ar0
0253 A833       330            mov r0, min_counter
0255 1200CC     330            lcall ?Display_BCD
0258 D000       330            pop ar0
025A            331   
025A AC34       332       mov R4, hour_counter
025C BC0210     333       CJNE R4, #2, hourskip
025F 753400     334       mov hour_counter, #0x00
0262            335   ;Check states and run if else
0262 AC35       336       mov R4, day_state
0264 BC0005     337       cjne R4, #0, PMtoAM
0267            338   ;PMtoAM
0267 753501     339       mov day_state, #1
026A 8003       340       sjmp hourskip
026C            341   PMtoAM:
026C 753500     342       mov day_state, #0
026F            343   
026F            344   hourskip:
026F C0E0       345            push acc
0271 7401       345            mov a, #1
0273 14         345            dec a
0274 1200C7     345            lcall ?Set_Cursor_1 ; Select column and row
0277 D0E0       345            pop acc
0279 C000       346            push ar0
027B A834       346            mov r0, hour_counter
027D 1200CC     346            lcall ?Display_BCD
0280 D000       346            pop ar0
0282            347   
0282            348   ;Check states and run alternate
0282 AC35       349       mov R4, day_state
0284 BC001F     350       CJNE R4, #0, timeAM
0287            351   timePM:
0287 C0E0       352            push acc
0289 740A       352            mov a, #10
028B 14         352            dec a
028C 1200C7     352            lcall ?Set_Cursor_1 ; Select column and row
028F D0E0       352            pop acc
0291 C083       353            push dph
0293 C082       353            push dpl
0295 C0E0       353            push acc
0297 9000F1     353            mov dptr, #PM
029A 1200BA     353            lcall ?Send_Constant_String
029D D0E0       353            pop acc
029F D082       353            pop dpl
02A1 D083       353            pop dph
02A3 0201B4     354       ljmp loop
02A6            355   timeAM:
02A6 C0E0       356            push acc
02A8 740A       356            mov a, #10
02AA 14         356            dec a
02AB 1200C7     356            lcall ?Set_Cursor_1 ; Select column and row
02AE D0E0       356            pop acc
02B0            356   
02B0 C083       357            push dph
02B2 C082       357            push dpl
02B4 C0E0       357            push acc
02B6 9000EE     357            mov dptr, #AM
02B9 1200BA     357            lcall ?Send_Constant_String
02BC D0E0       357            pop acc
02BE D082       357            pop dpl
02C0 D083       357            pop dph
02C2 0201B4     358       ljmp loop
02C5            359   
02C5            360   ;}}}
02C5            361   END
