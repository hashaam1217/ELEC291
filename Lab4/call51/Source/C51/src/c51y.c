
/*  A Bison parser, made from c51.y
    by GNU Bison version 1.28  */

#define YYBISON 1  /* Identify Bison output.  */

#define	IDENTIFIER	257
#define	TYPE_NAME	258
#define	CONSTANT	259
#define	STRING_LITERAL	260
#define	SIZEOF	261
#define	TYPEOF	262
#define	PTR_OP	263
#define	INC_OP	264
#define	DEC_OP	265
#define	LEFT_OP	266
#define	RIGHT_OP	267
#define	LE_OP	268
#define	GE_OP	269
#define	EQ_OP	270
#define	NE_OP	271
#define	AND_OP	272
#define	OR_OP	273
#define	MUL_ASSIGN	274
#define	DIV_ASSIGN	275
#define	MOD_ASSIGN	276
#define	ADD_ASSIGN	277
#define	SUB_ASSIGN	278
#define	LEFT_ASSIGN	279
#define	RIGHT_ASSIGN	280
#define	AND_ASSIGN	281
#define	XOR_ASSIGN	282
#define	OR_ASSIGN	283
#define	TYPEDEF	284
#define	EXTERN	285
#define	STATIC	286
#define	AUTO	287
#define	REGISTER	288
#define	CODE	289
#define	EEPROM	290
#define	INTERRUPT	291
#define	SFR	292
#define	SFR16	293
#define	SFR32	294
#define	AT	295
#define	SBIT	296
#define	REENTRANT	297
#define	USING	298
#define	XDATA	299
#define	DATA	300
#define	IDATA	301
#define	PDATA	302
#define	VAR_ARGS	303
#define	CRITICAL	304
#define	NONBANKED	305
#define	BANKED	306
#define	SHADOWREGS	307
#define	WPARAM	308
#define	CHAR	309
#define	SHORT	310
#define	INT	311
#define	LONG	312
#define	SIGNED	313
#define	UNSIGNED	314
#define	FLOAT	315
#define	DOUBLE	316
#define	FIXED16X16	317
#define	CONST	318
#define	VOLATILE	319
#define	VOID	320
#define	BIT	321
#define	STRUCT	322
#define	UNION	323
#define	ENUM	324
#define	RANGE	325
#define	FAR	326
#define	CASE	327
#define	DEFAULT	328
#define	IF	329
#define	ELSE	330
#define	SWITCH	331
#define	WHILE	332
#define	DO	333
#define	FOR	334
#define	GOTO	335
#define	CONTINUE	336
#define	BREAK	337
#define	RETURN	338
#define	NAKED	339
#define	JAVANATIVE	340
#define	OVERLAY	341
#define	INLINEASM	342
#define	IFX	343
#define	ADDRESS_OF	344
#define	GET_VALUE_AT_ADDRESS	345
#define	SPIL	346
#define	UNSPIL	347
#define	GETHBIT	348
#define	GETABIT	349
#define	GETBYTE	350
#define	GETWORD	351
#define	BITWISEAND	352
#define	UNARYMINUS	353
#define	IPUSH	354
#define	IPOP	355
#define	PCALL	356
#define	ENDFUNCTION	357
#define	JUMPTABLE	358
#define	RRC	359
#define	RLC	360
#define	CAST	361
#define	CALL	362
#define	PARAM	363
#define	NULLOP	364
#define	BLOCK	365
#define	LABEL	366
#define	RECEIVE	367
#define	SEND	368
#define	ARRAYINIT	369
#define	DUMMY_READ_VOLATILE	370
#define	ENDCRITICAL	371
#define	SWAP	372
#define	INLINE	373
#define	RESTRICT	374

#line 24 "c51.y"

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include "C51globl.h"
#include "C51symt.h"
#include "C51hasht.h"
#include "C51val.h"
#include "C51mem.h"
#include "C51ast.h"
#include "port.h"
#include "newalloc.h"
#include "C51err.h"
#include "C51util.h"

extern int yyerror (char *);
extern FILE     *yyin;
int NestLevel = 0 ;     /* current NestLevel       */
int stackPtr  = 1 ;     /* stack pointer           */
int xstackPtr = 0 ;     /* xstack pointer          */
int reentrant = 0 ;
int blockNo   = 0 ;     /* sequential block number  */
int currBlockno=0 ;
int inCritical= 0 ;
int seqPointNo= 1 ;     /* sequence point number */
int ignoreTypedefType=0;
extern int yylex();
int yyparse(void);
extern int noLineno ;
char lbuff[1024];      /* local buffer */
int EmptyIF;

/* break & continue stacks */
STACK_DCL(continueStack  ,symbol *,MAX_NEST_LEVEL)
STACK_DCL(breakStack  ,symbol *,MAX_NEST_LEVEL)
STACK_DCL(forStack  ,symbol *,MAX_NEST_LEVEL)
STACK_DCL(swStk   ,ast   *,MAX_NEST_LEVEL)
STACK_DCL(blockNum,int,MAX_NEST_LEVEL*3)

value *cenum = NULL  ;  /* current enumeration  type chain*/
bool uselessDecl = TRUE;

#define YYDEBUG 1


#line 71 "c51.y"
typedef union {
    symbol      *sym ;      /* symbol table pointer       */
    structdef   *sdef;      /* structure definition       */
    char        yychar[C51_NAME_MAX+1];
    sym_link    *lnk ;      /* declarator  or specifier   */
    int         yyint;      /* integer value returned     */
    value       *val ;      /* for integer constant       */
    initList    *ilist;     /* initial list               */
	designation *dsgn;      /* designator                 */
    const char  *yyinline;  /* inlined assembler code     */
    ast         *asts;      /* expression tree            */
} YYSTYPE;
#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		434
#define	YYFLAG		-32768
#define	YYNTBASE	145

#define YYTRANSLATE(x) ((unsigned)(x) <= 374 ? yytranslate[x] : 253)

static const short yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,   132,     2,     2,     2,   134,   127,     2,   121,
   122,   128,   129,   126,   130,   125,   133,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,   140,   142,   135,
   141,   136,   139,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
   123,     2,   124,   137,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,   143,   138,   144,   131,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,
    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,
    57,    58,    59,    60,    61,    62,    63,    64,    65,    66,
    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,
    77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,
    97,    98,    99,   100,   101,   102,   103,   104,   105,   106,
   107,   108,   109,   110,   111,   112,   113,   114,   115,   116,
   117,   118,   119,   120
};

#if YYDEBUG != 0
static const short yyprhs[] = {     0,
     0,     1,     3,     5,     8,    10,    12,    15,    19,    21,
    24,    27,    29,    31,    33,    35,    37,    39,    41,    43,
    45,    47,    49,    52,    54,    56,    58,    62,    64,    66,
    71,    75,    80,    81,    86,    87,    92,    95,    98,   100,
   104,   106,   109,   112,   115,   118,   123,   126,   128,   130,
   132,   134,   136,   138,   140,   145,   147,   151,   155,   159,
   161,   165,   169,   171,   175,   179,   181,   185,   189,   193,
   197,   199,   203,   207,   209,   213,   215,   219,   221,   225,
   227,   228,   233,   235,   236,   241,   243,   244,   251,   253,
   257,   259,   261,   263,   265,   267,   269,   271,   273,   275,
   277,   279,   281,   282,   287,   289,   292,   296,   298,   300,
   303,   305,   308,   310,   313,   315,   319,   321,   325,   326,
   328,   331,   333,   336,   340,   343,   345,   347,   349,   351,
   353,   355,   357,   360,   362,   366,   368,   370,   372,   374,
   376,   378,   380,   382,   384,   386,   388,   390,   392,   394,
   396,   398,   400,   402,   404,   406,   408,   410,   412,   414,
   416,   418,   421,   423,   425,   426,   433,   436,   438,   440,
   442,   443,   445,   447,   450,   454,   456,   460,   462,   465,
   469,   470,   475,   481,   484,   486,   489,   493,   496,   499,
   500,   502,   505,   507,   509,   511,   514,   516,   519,   521,
   525,   529,   534,   538,   539,   545,   550,   552,   555,   558,
   562,   564,   566,   568,   571,   573,   577,   579,   583,   585,
   589,   592,   594,   596,   599,   601,   603,   606,   610,   613,
   617,   621,   626,   629,   633,   637,   638,   644,   646,   650,
   655,   658,   663,   665,   667,   669,   671,   673,   675,   677,
   680,   682,   685,   688,   692,   693,   697,   699,   701,   704,
   708,   712,   717,   720,   722,   725,   727,   730,   732,   735,
   738,   739,   740,   748,   749,   756,   758,   760,   762,   763,
   770,   778,   788,   789,   791,   795,   798,   801,   804,   808
};

static const short yyrhs[] = {    -1,
   146,     0,   147,     0,   146,   147,     0,   148,     0,   180,
     0,   211,   151,     0,   181,   211,   151,     0,   150,     0,
   150,   149,     0,    44,   179,     0,    43,     0,    50,     0,
    85,     0,    86,     0,    87,     0,    51,     0,    53,     0,
    54,     0,    52,     0,   191,     0,   237,     0,   238,   237,
     0,   252,     0,     5,     0,   153,     0,   121,   177,   122,
     0,     6,     0,   152,     0,   154,   123,   177,   124,     0,
   154,   121,   122,     0,   154,   121,   157,   122,     0,     0,
   154,   125,   155,   252,     0,     0,   154,     9,   156,   252,
     0,   154,    10,     0,   154,    11,     0,   175,     0,   175,
   126,   157,     0,   154,     0,    10,   158,     0,    11,   158,
     0,   159,   160,     0,     7,   158,     0,     7,   121,   224,
   122,     0,     8,   158,     0,   127,     0,   128,     0,   129,
     0,   130,     0,   131,     0,   132,     0,   158,     0,   121,
   224,   122,   160,     0,   160,     0,   161,   128,   160,     0,
   161,   133,   160,     0,   161,   134,   160,     0,   161,     0,
   162,   129,   161,     0,   162,   130,   161,     0,   162,     0,
   163,    12,   162,     0,   163,    13,   162,     0,   163,     0,
   164,   135,   163,     0,   164,   136,   163,     0,   164,    14,
   163,     0,   164,    15,   163,     0,   164,     0,   165,    16,
   164,     0,   165,    17,   164,     0,   165,     0,   166,   127,
   165,     0,   166,     0,   167,   137,   166,     0,   167,     0,
   168,   138,   167,     0,   168,     0,     0,   169,    18,   170,
   168,     0,   169,     0,     0,   171,    19,   172,   169,     0,
   171,     0,     0,   171,   139,   174,   171,   140,   173,     0,
   173,     0,   160,   176,   175,     0,   141,     0,    20,     0,
    21,     0,    22,     0,    23,     0,    24,     0,    25,     0,
    26,     0,    27,     0,    28,     0,    29,     0,   175,     0,
     0,   177,   126,   178,   175,     0,   173,     0,   181,   142,
     0,   181,   183,   142,     0,   182,     0,   189,     0,   189,
   182,     0,   192,     0,   192,   182,     0,   190,     0,   190,
   182,     0,   184,     0,   183,   126,   184,     0,   209,     0,
   209,   141,   228,     0,     0,   186,     0,   187,   141,     0,
   188,     0,   187,   188,     0,   123,   179,   124,     0,   125,
   252,     0,    30,     0,    31,     0,    32,     0,    33,     0,
    34,     0,   119,     0,    37,     0,    37,   179,     0,   193,
     0,   193,    41,   179,     0,    55,     0,    56,     0,    57,
     0,    58,     0,    59,     0,    60,     0,    66,     0,    64,
     0,    65,     0,   120,     0,    61,     0,    63,     0,    45,
     0,    35,     0,    36,     0,    46,     0,    47,     0,    48,
     0,    67,     0,   196,     0,   205,     0,     4,     0,   194,
     0,    42,     0,   195,     0,    38,     0,    38,    52,     0,
    39,     0,    40,     0,     0,   198,   199,   197,   143,   201,
   144,     0,   198,   200,     0,    68,     0,    69,     0,   200,
     0,     0,   252,     0,   202,     0,   201,   202,     0,   218,
   203,   142,     0,   204,     0,   203,   126,   204,     0,   209,
     0,   140,   179,     0,   209,   140,   179,     0,     0,    70,
   143,   206,   144,     0,    70,   252,   143,   206,   144,     0,
    70,   252,     0,   207,     0,   206,   126,     0,   206,   126,
   207,     0,   252,   208,     0,   141,   179,     0,     0,   210,
     0,   216,   210,     0,   212,     0,   213,     0,   212,     0,
   216,   212,     0,   214,     0,   214,   149,     0,   252,     0,
   121,   209,   122,     0,   210,   123,   124,     0,   210,   123,
   179,   124,     0,   213,   121,   122,     0,     0,   213,   121,
   215,   221,   122,     0,   213,   121,   220,   122,     0,   217,
     0,   217,   218,     0,   217,   216,     0,   217,   218,   216,
     0,   128,     0,   219,     0,   192,     0,   219,   192,     0,
   252,     0,   220,   126,   252,     0,   222,     0,   222,   126,
    49,     0,   223,     0,   222,   126,   223,     0,   218,   209,
     0,   224,     0,   218,     0,   218,   225,     0,   216,     0,
   226,     0,   216,   226,     0,   121,   225,   122,     0,   123,
   124,     0,   123,   179,   124,     0,   226,   123,   124,     0,
   226,   123,   179,   124,     0,   121,   122,     0,   121,   221,
   122,     0,   226,   121,   122,     0,     0,   226,   121,   227,
   221,   122,     0,   175,     0,   143,   229,   144,     0,   143,
   229,   126,   144,     0,   185,   228,     0,   229,   126,   185,
   228,     0,   233,     0,   237,     0,   240,     0,   242,     0,
   248,     0,   251,     0,   232,     0,    88,   142,     0,    50,
     0,   231,   230,     0,   252,   140,     0,    73,   179,   140,
     0,     0,    74,   234,   140,     0,   143,     0,   144,     0,
   235,   236,     0,   235,   239,   236,     0,   235,   238,   236,
     0,   235,   238,   239,   236,     0,     1,   142,     0,   180,
     0,   238,   180,     0,   230,     0,   239,   230,     0,   142,
     0,   177,   142,     0,    76,   230,     0,     0,     0,    75,
   121,   177,   122,   243,   230,   241,     0,     0,    77,   121,
   177,   122,   244,   230,     0,    78,     0,    79,     0,    80,
     0,     0,   245,   121,   177,   122,   249,   230,     0,   246,
   230,    78,   121,   177,   122,   142,     0,   247,   121,   250,
   142,   250,   142,   250,   122,   230,     0,     0,   177,     0,
    81,   252,   142,     0,    82,   142,     0,    83,   142,     0,
    84,   142,     0,    84,   177,   142,     0,     3,     0
};

#endif

#if YYDEBUG != 0
static const short yyrline[] = { 0,
   139,   143,   147,   148,   152,   155,   181,   186,   195,   196,
   200,   204,   207,   210,   213,   216,   219,   225,   228,   231,
   240,   249,   250,   258,   259,   260,   261,   265,   269,   270,
   271,   273,   277,   278,   284,   285,   291,   293,   298,   299,
   303,   304,   305,   306,   307,   308,   309,   313,   314,   315,
   316,   317,   318,   322,   323,   327,   328,   329,   330,   334,
   335,   336,   340,   341,   342,   346,   347,   348,   349,   350,
   354,   355,   356,   360,   361,   365,   366,   370,   371,   375,
   376,   377,   381,   382,   383,   387,   388,   388,   396,   397,
   442,   443,   444,   445,   446,   447,   448,   449,   450,   451,
   452,   456,   457,   457,   461,   465,   472,   489,   492,   493,
   498,   499,   504,   505,   513,   514,   518,   519,   523,   524,
   528,   532,   533,   537,   559,   564,   568,   572,   576,   580,
   587,   594,   595,   608,   609,   619,   624,   629,   634,   639,
   644,   649,   654,   658,   662,   666,   671,   676,   680,   684,
   688,   692,   696,   700,   709,   714,   720,   729,   733,   741,
   745,   753,   764,   775,   787,   800,   836,   855,   856,   860,
   861,   869,   881,   882,   895,   918,   919,   927,   928,   941,
   957,   962,   967,   987,  1001,  1002,  1003,  1011,  1032,  1045,
  1058,  1059,  1067,  1068,  1072,  1073,  1081,  1082,  1114,  1115,
  1116,  1125,  1157,  1158,  1159,  1184,  1194,  1195,  1207,  1213,
  1252,  1259,  1262,  1264,  1272,  1273,  1281,  1282,  1286,  1287,
  1295,  1305,  1314,  1315,  1332,  1333,  1334,  1341,  1342,  1347,
  1353,  1359,  1367,  1368,  1369,  1381,  1381,  1405,  1406,  1407,
  1411,  1412,  1421,  1422,  1423,  1424,  1425,  1426,  1427,  1428,
  1439,  1448,  1458,  1460,  1467,  1468,  1476,  1485,  1489,  1490,
  1491,  1492,  1495,  1499,  1512,  1538,  1539,  1543,  1544,  1548,
  1549,  1554,  1554,  1563,  1580,  1588,  1602,  1617,  1636,  1637,
  1645,  1655,  1683,  1684,  1688,  1693,  1706,  1716,  1725,  1737
};
#endif


#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)

static const char * const yytname[] = {   "$","error","$undefined.","IDENTIFIER",
"TYPE_NAME","CONSTANT","STRING_LITERAL","SIZEOF","TYPEOF","PTR_OP","INC_OP",
"DEC_OP","LEFT_OP","RIGHT_OP","LE_OP","GE_OP","EQ_OP","NE_OP","AND_OP","OR_OP",
"MUL_ASSIGN","DIV_ASSIGN","MOD_ASSIGN","ADD_ASSIGN","SUB_ASSIGN","LEFT_ASSIGN",
"RIGHT_ASSIGN","AND_ASSIGN","XOR_ASSIGN","OR_ASSIGN","TYPEDEF","EXTERN","STATIC",
"AUTO","REGISTER","CODE","EEPROM","INTERRUPT","SFR","SFR16","SFR32","AT","SBIT",
"REENTRANT","USING","XDATA","DATA","IDATA","PDATA","VAR_ARGS","CRITICAL","NONBANKED",
"BANKED","SHADOWREGS","WPARAM","CHAR","SHORT","INT","LONG","SIGNED","UNSIGNED",
"FLOAT","DOUBLE","FIXED16X16","CONST","VOLATILE","VOID","BIT","STRUCT","UNION",
"ENUM","RANGE","FAR","CASE","DEFAULT","IF","ELSE","SWITCH","WHILE","DO","FOR",
"GOTO","CONTINUE","BREAK","RETURN","NAKED","JAVANATIVE","OVERLAY","INLINEASM",
"IFX","ADDRESS_OF","GET_VALUE_AT_ADDRESS","SPIL","UNSPIL","GETHBIT","GETABIT",
"GETBYTE","GETWORD","BITWISEAND","UNARYMINUS","IPUSH","IPOP","PCALL","ENDFUNCTION",
"JUMPTABLE","RRC","RLC","CAST","CALL","PARAM","NULLOP","BLOCK","LABEL","RECEIVE",
"SEND","ARRAYINIT","DUMMY_READ_VOLATILE","ENDCRITICAL","SWAP","INLINE","RESTRICT",
"'('","')'","'['","']'","'.'","','","'&'","'*'","'+'","'-'","'~'","'!'","'/'",
"'%'","'<'","'>'","'^'","'|'","'?'","':'","'='","';'","'{'","'}'","file","program",
"external_definition","function_definition","function_attribute","function_attributes",
"function_body","primary_expr","string_literal","postfix_expr","@1","@2","argument_expr_list",
"unary_expr","unary_operator","cast_expr","multiplicative_expr","additive_expr",
"shift_expr","relational_expr","equality_expr","and_expr","exclusive_or_expr",
"inclusive_or_expr","logical_and_expr","@3","logical_or_expr","@4","conditional_expr",
"@5","assignment_expr","assignment_operator","expr","@6","constant_expr","declaration",
"declaration_specifiers","declaration_specifiers_","init_declarator_list","init_declarator",
"designation_opt","designation","designator_list","designator","storage_class_specifier",
"function_specifier","Interrupt_storage","type_specifier","type_specifier2",
"sfr_reg_bit","sfr_attributes","struct_or_union_specifier","@7","struct_or_union",
"opt_stag","stag","struct_declaration_list","struct_declaration","struct_declarator_list",
"struct_declarator","enum_specifier","enumerator_list","enumerator","opt_assign_expr",
"declarator","declarator3","function_declarator","declarator2_function_attributes",
"declarator2","function_declarator2","@8","pointer","unqualified_pointer","type_specifier_list",
"type_specifier_list_","identifier_list","parameter_type_list","parameter_list",
"parameter_declaration","type_name","abstract_declarator","abstract_declarator2",
"@9","initializer","initializer_list","statement","critical","critical_statement",
"labeled_statement","@10","start_block","end_block","compound_statement","declaration_list",
"statement_list","expression_statement","else_statement","selection_statement",
"@11","@12","while","do","for","iteration_statement","@13","expr_opt","jump_statement",
"identifier", NULL
};
#endif

static const short yyr1[] = {     0,
   145,   145,   146,   146,   147,   147,   148,   148,   149,   149,
   150,   150,   150,   150,   150,   150,   150,   150,   150,   150,
   150,   151,   151,   152,   152,   152,   152,   153,   154,   154,
   154,   154,   155,   154,   156,   154,   154,   154,   157,   157,
   158,   158,   158,   158,   158,   158,   158,   159,   159,   159,
   159,   159,   159,   160,   160,   161,   161,   161,   161,   162,
   162,   162,   163,   163,   163,   164,   164,   164,   164,   164,
   165,   165,   165,   166,   166,   167,   167,   168,   168,   169,
   170,   169,   171,   172,   171,   173,   174,   173,   175,   175,
   176,   176,   176,   176,   176,   176,   176,   176,   176,   176,
   176,   177,   178,   177,   179,   180,   180,   181,   182,   182,
   182,   182,   182,   182,   183,   183,   184,   184,   185,   185,
   186,   187,   187,   188,   188,   189,   189,   189,   189,   189,
   190,   191,   191,   192,   192,   193,   193,   193,   193,   193,
   193,   193,   193,   193,   193,   193,   193,   193,   193,   193,
   193,   193,   193,   193,   193,   193,   193,   193,   194,   194,
   195,   195,   195,   195,   197,   196,   196,   198,   198,   199,
   199,   200,   201,   201,   202,   203,   203,   204,   204,   204,
   204,   205,   205,   205,   206,   206,   206,   207,   208,   208,
   209,   209,   210,   210,   211,   211,   212,   212,   213,   213,
   213,   213,   214,   215,   214,   214,   216,   216,   216,   216,
   217,   218,   219,   219,   220,   220,   221,   221,   222,   222,
   223,   223,   224,   224,   225,   225,   225,   226,   226,   226,
   226,   226,   226,   226,   226,   227,   226,   228,   228,   228,
   229,   229,   230,   230,   230,   230,   230,   230,   230,   230,
   231,   232,   233,   233,   234,   233,   235,   236,   237,   237,
   237,   237,   237,   238,   238,   239,   239,   240,   240,   241,
   241,   243,   242,   244,   242,   245,   246,   247,   249,   248,
   248,   248,   250,   250,   251,   251,   251,   251,   251,   252
};

static const short yyr2[] = {     0,
     0,     1,     1,     2,     1,     1,     2,     3,     1,     2,
     2,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     2,     1,     1,     1,     3,     1,     1,     4,
     3,     4,     0,     4,     0,     4,     2,     2,     1,     3,
     1,     2,     2,     2,     2,     4,     2,     1,     1,     1,
     1,     1,     1,     1,     4,     1,     3,     3,     3,     1,
     3,     3,     1,     3,     3,     1,     3,     3,     3,     3,
     1,     3,     3,     1,     3,     1,     3,     1,     3,     1,
     0,     4,     1,     0,     4,     1,     0,     6,     1,     3,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     0,     4,     1,     2,     3,     1,     1,     2,
     1,     2,     1,     2,     1,     3,     1,     3,     0,     1,
     2,     1,     2,     3,     2,     1,     1,     1,     1,     1,
     1,     1,     2,     1,     3,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     2,     1,     1,     0,     6,     2,     1,     1,     1,
     0,     1,     1,     2,     3,     1,     3,     1,     2,     3,
     0,     4,     5,     2,     1,     2,     3,     2,     2,     0,
     1,     2,     1,     1,     1,     2,     1,     2,     1,     3,
     3,     4,     3,     0,     5,     4,     1,     2,     2,     3,
     1,     1,     1,     2,     1,     3,     1,     3,     1,     3,
     2,     1,     1,     2,     1,     1,     2,     3,     2,     3,
     3,     4,     2,     3,     3,     0,     5,     1,     3,     4,
     2,     4,     1,     1,     1,     1,     1,     1,     1,     2,
     1,     2,     2,     3,     0,     3,     1,     1,     2,     3,
     3,     4,     2,     1,     2,     1,     2,     1,     2,     2,
     0,     0,     7,     0,     6,     1,     1,     1,     0,     6,
     7,     9,     0,     1,     3,     2,     2,     2,     3,     1
};

static const short yydefact[] = {     1,
   290,   157,   126,   127,   128,   129,   130,   149,   150,   161,
   163,   164,   159,   148,   151,   152,   153,   136,   137,   138,
   139,   140,   141,   146,   147,   143,   144,   142,   154,   168,
   169,     0,   131,   145,     0,   211,     2,     3,     5,     6,
     0,   108,   109,   113,   111,   134,   158,   160,   155,   171,
   156,     0,     0,   195,   194,   197,     0,   207,   199,   162,
     0,   184,     0,   191,   193,     0,     4,   106,     0,   115,
   117,     0,     0,   110,   114,   112,     0,   165,   167,   172,
     0,     0,   257,     7,   264,     0,     0,    22,     0,   204,
   132,    12,     0,    13,    17,    20,    18,    19,    14,    15,
    16,   198,     9,    21,   196,   213,   209,   208,   212,     0,
   185,   190,     0,   200,   192,     0,   107,     0,     8,    25,
    28,     0,     0,     0,     0,     0,    48,    49,    50,    51,
    52,    53,    29,    26,    41,    54,     0,    56,    60,    63,
    66,    71,    74,    76,    78,    80,    83,    86,   105,   135,
    24,     0,   201,     0,   263,   251,     0,   255,     0,     0,
   276,   277,   278,     0,     0,     0,     0,     0,   268,   258,
    56,    89,   102,     0,   266,     0,   249,   243,   259,   244,
     0,     0,   245,   246,     0,     0,     0,   247,   248,    24,
   265,    23,   203,     0,     0,   215,   133,    11,    10,   210,
   214,   186,   182,     0,   188,     0,   116,   119,   238,   118,
     0,    45,     0,    47,    42,    43,     0,   223,     0,    35,
    37,    38,     0,     0,    33,    44,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,    81,    84,    87,     0,   202,     0,     0,     0,
     0,     0,   286,   287,   288,     0,   250,    92,    93,    94,
    95,    96,    97,    98,    99,   100,   101,    91,     0,   103,
   269,   252,   261,     0,   267,   260,     0,     0,   283,   253,
   223,     0,   217,   219,   222,   206,     0,   187,   189,   183,
     0,     0,     0,   120,     0,   122,     0,     0,    27,     0,
     0,   225,   224,   226,     0,     0,    31,     0,    39,     0,
     0,    57,    58,    59,    61,    62,    64,    65,    69,    70,
    67,    68,    72,    73,    75,    77,    79,     0,     0,     0,
     0,   173,   181,   254,   256,     0,     0,   285,   289,    90,
     0,   262,     0,     0,   284,     0,     0,   221,   225,   205,
     0,   216,     0,   125,   241,   121,   123,   119,   239,    46,
   233,     0,     0,   229,     0,   227,   236,     0,    55,    36,
    32,     0,    30,    34,    82,    85,     0,   166,   174,     0,
     0,   176,   178,   272,   274,   104,   279,     0,   283,   218,
   220,   124,   240,     0,   234,   228,   230,   235,     0,   231,
     0,    40,     0,   179,   181,   175,     0,     0,     0,     0,
     0,     0,   242,     0,   232,    88,   177,   180,   271,   275,
   280,     0,   283,   237,     0,   273,   281,     0,   270,     0,
   282,     0,     0,     0
};

static const short yydefgoto[] = {   432,
    37,    38,    39,   102,   103,    84,   133,   134,   135,   311,
   306,   308,   136,   137,   171,   139,   140,   141,   142,   143,
   144,   145,   146,   147,   328,   148,   329,   172,   330,   173,
   269,   174,   341,   150,    85,    86,    42,    69,    70,   293,
   294,   295,   296,    43,    44,   104,    45,    46,    47,    48,
    49,   152,    50,    78,    79,   331,   332,   381,   382,    51,
   110,   111,   205,    71,    64,    53,    65,    55,    56,   194,
    66,    58,   281,   109,   195,   362,   283,   284,   285,   303,
   304,   399,   210,   297,   175,   176,   177,   178,   249,    87,
   179,   180,    89,   182,   183,   426,   184,   408,   409,   185,
   186,   187,   188,   410,   346,   189,   151
};

static const short yypact[] = {  1038,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   -38,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,     9,-32768,-32768,    23,-32768,  1038,-32768,-32768,-32768,
    13,-32768,  1248,  1248,  1248,   -18,-32768,-32768,-32768,    33,
-32768,   -65,   610,    30,   -57,   507,    28,  1172,-32768,-32768,
    33,   -50,   -26,   -65,-32768,    28,-32768,-32768,   -64,-32768,
   -53,   610,    28,-32768,-32768,-32768,   872,-32768,   -44,-32768,
   765,   -28,-32768,-32768,-32768,    13,   411,-32768,   610,    17,
   872,-32768,   872,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,   507,-32768,    30,-32768,-32768,   -11,  1285,   -97,
-32768,    -4,    33,-32768,   -65,    23,-32768,   383,-32768,-32768,
-32768,   923,   935,   935,   935,   780,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,    42,-32768,   872,-32768,    67,   -87,
   117,    62,   210,    34,   -14,    36,   151,    -8,-32768,-32768,
-32768,    41,-32768,    53,-32768,-32768,   872,-32768,    75,    78,
-32768,-32768,-32768,    33,    79,    86,   579,    92,-32768,-32768,
   216,-32768,-32768,   -42,-32768,   681,-32768,-32768,-32768,-32768,
   411,   495,-32768,-32768,   103,   681,   127,-32768,-32768,   138,
-32768,-32768,-32768,  1285,    44,-32768,-32768,-32768,-32768,-32768,
-32768,    33,-32768,   872,-32768,   -77,-32768,    35,-32768,-32768,
   780,-32768,   872,-32768,-32768,-32768,    61,    57,   158,-32768,
-32768,-32768,   793,   872,-32768,-32768,   872,   872,   872,   872,
   872,   872,   872,   872,   872,   872,   872,   872,   872,   872,
   872,   872,-32768,-32768,-32768,  1285,-32768,   143,   146,   872,
   872,   147,-32768,-32768,-32768,   -23,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   872,-32768,
-32768,-32768,-32768,   495,-32768,-32768,   872,   213,   872,-32768,
    15,   172,   169,-32768,-32768,-32768,    33,-32768,-32768,-32768,
   872,    33,   383,-32768,   -85,-32768,   -55,   176,-32768,  1125,
   848,    70,-32768,    91,   872,    33,-32768,   178,   175,    96,
    33,-32768,-32768,-32768,    67,    67,   -87,   -87,   117,   117,
   117,   117,    62,    62,   210,    34,   -14,   872,   872,   872,
   677,-32768,    14,-32768,-32768,    82,    83,-32768,-32768,-32768,
   872,-32768,    84,   182,   179,   167,  1078,-32768,    27,-32768,
   970,-32768,   186,-32768,-32768,-32768,-32768,   -19,-32768,-32768,
-32768,   190,   192,-32768,   191,    91,   194,   860,-32768,-32768,
-32768,   872,-32768,-32768,    36,   151,     5,-32768,-32768,   872,
   -21,-32768,   177,-32768,-32768,-32768,-32768,   872,   872,-32768,
-32768,-32768,-32768,   383,-32768,-32768,-32768,-32768,  1285,-32768,
   196,-32768,   872,-32768,    14,-32768,   872,   681,   681,   681,
    85,   181,-32768,   199,-32768,-32768,-32768,-32768,   242,-32768,
-32768,   185,   872,-32768,   681,-32768,-32768,   206,-32768,   681,
-32768,   330,   334,-32768
};

static const short yypgoto[] = {-32768,
-32768,   300,-32768,   235,-32768,   267,-32768,-32768,-32768,-32768,
-32768,   -32,   108,-32768,    31,    19,    24,    18,    37,   102,
   107,   101,    16,    21,-32768,    22,-32768,   -72,-32768,   -90,
-32768,  -104,-32768,   -78,     8,    46,   173,-32768,   237,    -3,
-32768,-32768,    63,-32768,-32768,-32768,   -54,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,    25,-32768,   -43,-32768,
   250,   162,-32768,   -34,     2,   324,    54,-32768,-32768,-32768,
     7,-32768,   -52,-32768,-32768,  -184,-32768,    26,  -101,  -267,
  -268,-32768,  -266,-32768,   -84,-32768,-32768,-32768,-32768,-32768,
  -112,    29,   279,   187,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,  -329,-32768,     0
};


#define	YYLAST		1405


static const short yytable[] = {    59,
    63,    52,   154,   106,   149,   108,    57,    40,   149,   282,
   244,     1,   197,    60,   198,     1,     1,     1,   149,     1,
   149,   217,    77,   244,   219,     1,   355,   209,   202,     1,
     1,    62,   363,   366,    59,     1,    59,   291,    52,   292,
    59,   230,   231,    57,    40,    41,   203,    73,   202,    80,
   220,   221,   222,    54,   201,   356,    59,    81,    52,   412,
   112,   116,   256,    90,   107,    59,   290,   115,   273,   276,
   358,   106,    59,   218,   115,   234,   235,   117,   248,   363,
   366,    88,    41,   270,   149,    59,   190,   118,   359,   196,
    54,   272,   113,   428,    54,   114,   191,   275,  -170,   271,
    88,   278,   270,   291,   405,   292,   217,   138,   217,   298,
   105,   138,   112,   155,   200,    59,    36,   192,   339,   310,
   406,   138,   241,   138,   393,   289,   105,   413,   232,   233,
   245,   149,   309,    35,    35,   347,   204,   301,   193,   106,
    36,    36,    36,    35,   403,   336,   337,   347,    35,   301,
    36,    61,  -193,   380,    68,  -193,   106,   291,   218,   292,
   240,   342,   223,   252,   224,   286,   225,   226,   243,   287,
  -193,  -193,   343,   242,   345,   190,   247,   300,   340,   301,
   190,   190,   299,   246,    36,   190,   270,   138,   191,   275,
   300,   106,   301,   333,   227,   250,   236,   237,   251,   228,
   229,   112,   209,   384,   385,   387,   422,   270,   270,   270,
   270,   367,   353,   368,   414,    74,    75,    76,   149,   373,
   253,   270,   365,   277,   302,   238,   239,   254,   149,   212,
   214,   215,   216,   257,   138,   258,   259,   260,   261,   262,
   263,   264,   265,   266,   267,   106,   348,   279,   315,   316,
   386,   319,   320,   321,   322,   317,   318,   312,   313,   314,
   138,   138,   138,   138,   138,   138,   138,   138,   138,   138,
   138,   138,   138,   190,   323,   324,   106,   280,   333,   305,
    59,   309,   334,   411,   345,   335,   352,   349,   338,   401,
   344,   354,   106,   350,   351,   149,   106,   360,   383,   371,
   372,   404,   388,   209,   270,   370,   302,   149,   389,   392,
   374,   395,    63,   396,   397,   398,   407,   425,   345,   415,
   424,   138,   423,   419,   420,   421,   427,   430,   418,   433,
   416,   138,    59,   434,   149,   369,    67,   199,   119,   402,
   429,   325,   327,   375,   106,   431,    59,   326,    59,   376,
   115,   377,   207,   349,   394,   379,   268,   357,   138,   138,
   138,   417,   206,   288,    72,   181,     0,   274,     0,     0,
   383,     0,     0,     0,     0,     0,   391,     0,     0,     0,
     0,     0,     0,     0,     0,     1,     0,   120,   121,   122,
   123,     0,   124,   125,     0,     0,     0,     0,   138,     0,
     0,     0,     0,     0,    59,     0,     0,   190,   190,   190,
   138,    82,     0,     1,     2,   120,   121,   122,   123,     0,
   124,   125,     0,     0,   190,     0,     0,     0,     0,   190,
     0,     0,     0,   138,     0,     0,     0,   138,     0,     0,
     3,     4,     5,     6,     7,     8,     9,     0,    10,    11,
    12,     0,    13,     0,     0,    14,    15,    16,    17,     0,
   156,     0,     0,     0,     0,    18,    19,    20,    21,    22,
    23,    24,     0,    25,    26,    27,    28,    29,    30,    31,
    32,     0,     0,   157,   158,   159,     0,   160,   161,   162,
   163,   164,   165,   166,   167,    82,     0,     1,   168,   120,
   121,   122,   123,   126,   124,   125,     0,     0,     0,   127,
   128,   129,   130,   131,   132,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   208,     0,     0,     0,    33,
    34,   126,     0,     0,     0,     0,     0,   127,   128,   129,
   130,   131,   132,    91,   156,     0,     0,     0,     0,    92,
    93,     0,   169,    83,   170,     0,    94,    95,    96,    97,
    98,     0,     0,     0,     0,     0,     0,   157,   158,   159,
     0,   160,   161,   162,   163,   164,   165,   166,   167,     0,
     0,     1,   168,   120,   121,   122,   123,     0,   124,   125,
     0,    99,   100,   101,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
    82,     0,     0,     2,     0,   126,     0,     0,     0,     0,
     0,   127,   128,   129,   130,   131,   132,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   169,    83,   170,     3,
     4,     5,     6,     7,     8,     9,     0,    10,    11,    12,
     0,    13,     0,     0,    14,    15,    16,    17,     0,     0,
     0,     0,     0,     0,    18,    19,    20,    21,    22,    23,
    24,     0,    25,    26,    27,    28,    29,    30,    31,    32,
     2,    82,     0,     1,     0,   120,   121,   122,   123,     0,
   124,   125,     0,     0,     0,     0,     0,     0,     0,   126,
     0,     0,     0,     0,     0,   127,   128,   129,   130,   131,
   132,     8,     9,     0,    10,    11,    12,     0,    13,     0,
   255,    14,    15,    16,    17,     0,     0,     0,    33,    34,
   156,    18,    19,    20,    21,    22,    23,    24,     0,    25,
    26,    27,    28,    29,    30,    31,    32,     0,     0,     0,
     0,     0,    83,   157,   158,   159,     0,   160,   161,   162,
   163,   164,   165,   166,   167,     0,     0,     1,   168,   120,
   121,   122,   123,     0,   124,   125,     0,     0,     0,     0,
     0,     0,     1,     2,   120,   121,   122,   123,     0,   124,
   125,     0,     0,     0,     0,     1,    34,   120,   121,   122,
   123,   126,   124,   125,     0,     0,     0,   127,   128,   129,
   130,   131,   132,     0,     8,     9,     0,    10,    11,    12,
   378,    13,   169,    83,    14,    15,    16,    17,     0,     0,
     0,     0,     0,     0,    18,    19,    20,    21,    22,    23,
    24,     0,    25,    26,    27,    28,    29,    30,    31,    32,
     1,     0,   120,   121,   122,   123,     0,   124,   125,     0,
     0,     0,     1,     0,   120,   121,   122,   123,     0,   124,
   125,     0,     0,     0,     1,     0,   120,   121,   122,   123,
     0,   124,   125,     0,     0,   126,     0,     0,   153,     0,
     0,   127,   128,   129,   130,   131,   132,     0,     0,    34,
   126,     0,     0,     0,     0,     0,   127,   128,   129,   130,
   131,   132,     0,   126,   307,     0,     0,     0,     0,   127,
   128,   129,   130,   131,   132,     1,     0,   120,   121,   122,
   123,     0,   124,   125,     0,     0,     0,     1,     0,   120,
   121,   122,   123,     0,   124,   125,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   126,     0,
     0,   364,     0,     2,   127,   128,   129,   130,   131,   132,
   126,     0,     0,   400,     0,     0,   127,   128,   129,   130,
   131,   132,   126,     0,     0,     0,     0,     0,   127,   128,
   129,   130,   131,   132,     8,     9,     0,    10,    11,    12,
     0,    13,     0,     0,    14,    15,    16,    17,   390,     0,
     0,     0,     0,     0,    18,    19,    20,    21,    22,    23,
    24,     0,    25,    26,    27,    28,    29,    30,    31,    32,
     1,     2,     0,   211,     0,     0,     0,     0,     0,   127,
   128,   129,   130,   131,   132,   213,     0,     0,     0,     0,
     0,   127,   128,   129,   130,   131,   132,     3,     4,     5,
     6,     7,     8,     9,     0,    10,    11,    12,     0,    13,
     1,     2,    14,    15,    16,    17,     0,     0,     0,    34,
     0,     0,    18,    19,    20,    21,    22,    23,    24,     0,
    25,    26,    27,    28,    29,    30,    31,    32,     0,     0,
     0,     0,     8,     9,     0,    10,    11,    12,     0,    13,
     0,     0,    14,    15,    16,    17,     0,     0,     2,     0,
     0,     0,    18,    19,    20,    21,    22,    23,    24,     0,
    25,    26,    27,    28,    29,    30,    31,    32,     0,     0,
     0,     0,     0,     0,     0,     0,    33,    34,    35,     8,
     9,     0,    10,    11,    12,    36,    13,     0,     0,    14,
    15,    16,    17,     0,     0,     2,     0,     0,     0,    18,
    19,    20,    21,    22,    23,    24,     0,    25,    26,    27,
    28,    29,    30,    31,    32,     0,     0,    34,   347,   361,
   301,     0,     0,     0,     0,    36,     8,     9,     0,    10,
    11,    12,     0,    13,     0,     0,    14,    15,    16,    17,
     0,     0,     0,     0,     0,     0,    18,    19,    20,    21,
    22,    23,    24,     0,    25,    26,    27,    28,    29,    30,
    31,    32,     0,     0,    34,   300,   361,   301,     0,     0,
     0,     2,    36,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     3,     4,     5,
     6,     7,     8,     9,     0,    10,    11,    12,     2,    13,
     0,    34,    14,    15,    16,    17,     0,     0,     0,    36,
     0,     0,    18,    19,    20,    21,    22,    23,    24,     0,
    25,    26,    27,    28,    29,    30,    31,    32,     0,     8,
     9,     0,    10,    11,    12,     0,    13,     0,     0,    14,
    15,    16,    17,     0,     0,     0,     0,     0,     0,    18,
    19,    20,    21,    22,    23,    24,     0,    25,    26,    27,
    28,    29,    30,    31,    32,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,    33,    34,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,    34
};

static const short yycheck[] = {     0,
    35,     0,    81,    58,    77,    58,     0,     0,    81,   194,
    19,     3,    91,    52,    93,     3,     3,     3,    91,     3,
    93,   126,    41,    19,   126,     3,   293,   118,   126,     3,
     3,    32,   300,   302,    35,     3,    37,   123,    37,   125,
    41,   129,   130,    37,    37,     0,   144,    41,   126,    50,
     9,    10,    11,     0,   109,   141,    57,   123,    57,   389,
    61,   126,   167,   121,    58,    66,   144,    66,   181,   182,
   126,   126,    73,   126,    73,    14,    15,   142,   157,   347,
   349,    53,    37,   126,   157,    86,    87,   141,   144,    90,
    37,   176,   143,   423,    41,   122,    89,   182,   143,   142,
    72,   186,   126,   123,   126,   125,   211,    77,   213,   211,
    57,    81,   113,   142,   108,   116,   128,    89,   142,   224,
   142,    91,   137,    93,   144,   204,    73,   394,    12,    13,
   139,   204,   223,   121,   121,   121,   141,   123,   122,   194,
   128,   128,   128,   121,   140,   250,   251,   121,   121,   123,
   128,   143,   123,   140,   142,   126,   211,   123,   211,   125,
   127,   274,   121,   164,   123,   122,   125,   137,    18,   126,
   141,   142,   277,   138,   279,   176,   124,   121,   269,   123,
   181,   182,   122,   143,   128,   186,   126,   157,   181,   274,
   121,   246,   123,   246,   128,   121,   135,   136,   121,   133,
   134,   202,   293,   122,   122,   122,   122,   126,   126,   126,
   126,   121,   291,   123,   399,    43,    44,    45,   291,   124,
   142,   126,   301,   121,   218,    16,    17,   142,   301,   122,
   123,   124,   125,   142,   204,    20,    21,    22,    23,    24,
    25,    26,    27,    28,    29,   300,   281,   121,   230,   231,
   341,   234,   235,   236,   237,   232,   233,   227,   228,   229,
   230,   231,   232,   233,   234,   235,   236,   237,   238,   239,
   240,   241,   242,   274,   238,   239,   331,   140,   331,   122,
   281,   372,   140,   388,   389,   140,   287,   281,   142,   368,
    78,   292,   347,   122,   126,   368,   351,   122,   333,   122,
   126,   380,   121,   394,   126,   306,   300,   380,   142,   124,
   311,   122,   347,   122,   124,   122,   140,    76,   423,   124,
   122,   291,   142,   408,   409,   410,   142,   122,   407,     0,
   403,   301,   333,     0,   407,   305,    37,   103,    72,   372,
   425,   240,   242,   328,   399,   430,   347,   241,   349,   329,
   349,   330,   116,   347,   358,   331,   141,   295,   328,   329,
   330,   405,   113,   202,    41,    87,    -1,   181,    -1,    -1,
   405,    -1,    -1,    -1,    -1,    -1,   351,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,     3,    -1,     5,     6,     7,
     8,    -1,    10,    11,    -1,    -1,    -1,    -1,   368,    -1,
    -1,    -1,    -1,    -1,   405,    -1,    -1,   408,   409,   410,
   380,     1,    -1,     3,     4,     5,     6,     7,     8,    -1,
    10,    11,    -1,    -1,   425,    -1,    -1,    -1,    -1,   430,
    -1,    -1,    -1,   403,    -1,    -1,    -1,   407,    -1,    -1,
    30,    31,    32,    33,    34,    35,    36,    -1,    38,    39,
    40,    -1,    42,    -1,    -1,    45,    46,    47,    48,    -1,
    50,    -1,    -1,    -1,    -1,    55,    56,    57,    58,    59,
    60,    61,    -1,    63,    64,    65,    66,    67,    68,    69,
    70,    -1,    -1,    73,    74,    75,    -1,    77,    78,    79,
    80,    81,    82,    83,    84,     1,    -1,     3,    88,     5,
     6,     7,     8,   121,    10,    11,    -1,    -1,    -1,   127,
   128,   129,   130,   131,   132,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,   143,    -1,    -1,    -1,   119,
   120,   121,    -1,    -1,    -1,    -1,    -1,   127,   128,   129,
   130,   131,   132,    37,    50,    -1,    -1,    -1,    -1,    43,
    44,    -1,   142,   143,   144,    -1,    50,    51,    52,    53,
    54,    -1,    -1,    -1,    -1,    -1,    -1,    73,    74,    75,
    -1,    77,    78,    79,    80,    81,    82,    83,    84,    -1,
    -1,     3,    88,     5,     6,     7,     8,    -1,    10,    11,
    -1,    85,    86,    87,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     1,    -1,    -1,     4,    -1,   121,    -1,    -1,    -1,    -1,
    -1,   127,   128,   129,   130,   131,   132,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,   142,   143,   144,    30,
    31,    32,    33,    34,    35,    36,    -1,    38,    39,    40,
    -1,    42,    -1,    -1,    45,    46,    47,    48,    -1,    -1,
    -1,    -1,    -1,    -1,    55,    56,    57,    58,    59,    60,
    61,    -1,    63,    64,    65,    66,    67,    68,    69,    70,
     4,     1,    -1,     3,    -1,     5,     6,     7,     8,    -1,
    10,    11,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   121,
    -1,    -1,    -1,    -1,    -1,   127,   128,   129,   130,   131,
   132,    35,    36,    -1,    38,    39,    40,    -1,    42,    -1,
   142,    45,    46,    47,    48,    -1,    -1,    -1,   119,   120,
    50,    55,    56,    57,    58,    59,    60,    61,    -1,    63,
    64,    65,    66,    67,    68,    69,    70,    -1,    -1,    -1,
    -1,    -1,   143,    73,    74,    75,    -1,    77,    78,    79,
    80,    81,    82,    83,    84,    -1,    -1,     3,    88,     5,
     6,     7,     8,    -1,    10,    11,    -1,    -1,    -1,    -1,
    -1,    -1,     3,     4,     5,     6,     7,     8,    -1,    10,
    11,    -1,    -1,    -1,    -1,     3,   120,     5,     6,     7,
     8,   121,    10,    11,    -1,    -1,    -1,   127,   128,   129,
   130,   131,   132,    -1,    35,    36,    -1,    38,    39,    40,
   144,    42,   142,   143,    45,    46,    47,    48,    -1,    -1,
    -1,    -1,    -1,    -1,    55,    56,    57,    58,    59,    60,
    61,    -1,    63,    64,    65,    66,    67,    68,    69,    70,
     3,    -1,     5,     6,     7,     8,    -1,    10,    11,    -1,
    -1,    -1,     3,    -1,     5,     6,     7,     8,    -1,    10,
    11,    -1,    -1,    -1,     3,    -1,     5,     6,     7,     8,
    -1,    10,    11,    -1,    -1,   121,    -1,    -1,   124,    -1,
    -1,   127,   128,   129,   130,   131,   132,    -1,    -1,   120,
   121,    -1,    -1,    -1,    -1,    -1,   127,   128,   129,   130,
   131,   132,    -1,   121,   122,    -1,    -1,    -1,    -1,   127,
   128,   129,   130,   131,   132,     3,    -1,     5,     6,     7,
     8,    -1,    10,    11,    -1,    -1,    -1,     3,    -1,     5,
     6,     7,     8,    -1,    10,    11,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   121,    -1,
    -1,   124,    -1,     4,   127,   128,   129,   130,   131,   132,
   121,    -1,    -1,   124,    -1,    -1,   127,   128,   129,   130,
   131,   132,   121,    -1,    -1,    -1,    -1,    -1,   127,   128,
   129,   130,   131,   132,    35,    36,    -1,    38,    39,    40,
    -1,    42,    -1,    -1,    45,    46,    47,    48,    49,    -1,
    -1,    -1,    -1,    -1,    55,    56,    57,    58,    59,    60,
    61,    -1,    63,    64,    65,    66,    67,    68,    69,    70,
     3,     4,    -1,   121,    -1,    -1,    -1,    -1,    -1,   127,
   128,   129,   130,   131,   132,   121,    -1,    -1,    -1,    -1,
    -1,   127,   128,   129,   130,   131,   132,    30,    31,    32,
    33,    34,    35,    36,    -1,    38,    39,    40,    -1,    42,
     3,     4,    45,    46,    47,    48,    -1,    -1,    -1,   120,
    -1,    -1,    55,    56,    57,    58,    59,    60,    61,    -1,
    63,    64,    65,    66,    67,    68,    69,    70,    -1,    -1,
    -1,    -1,    35,    36,    -1,    38,    39,    40,    -1,    42,
    -1,    -1,    45,    46,    47,    48,    -1,    -1,     4,    -1,
    -1,    -1,    55,    56,    57,    58,    59,    60,    61,    -1,
    63,    64,    65,    66,    67,    68,    69,    70,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,   119,   120,   121,    35,
    36,    -1,    38,    39,    40,   128,    42,    -1,    -1,    45,
    46,    47,    48,    -1,    -1,     4,    -1,    -1,    -1,    55,
    56,    57,    58,    59,    60,    61,    -1,    63,    64,    65,
    66,    67,    68,    69,    70,    -1,    -1,   120,   121,   122,
   123,    -1,    -1,    -1,    -1,   128,    35,    36,    -1,    38,
    39,    40,    -1,    42,    -1,    -1,    45,    46,    47,    48,
    -1,    -1,    -1,    -1,    -1,    -1,    55,    56,    57,    58,
    59,    60,    61,    -1,    63,    64,    65,    66,    67,    68,
    69,    70,    -1,    -1,   120,   121,   122,   123,    -1,    -1,
    -1,     4,   128,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    30,    31,    32,
    33,    34,    35,    36,    -1,    38,    39,    40,     4,    42,
    -1,   120,    45,    46,    47,    48,    -1,    -1,    -1,   128,
    -1,    -1,    55,    56,    57,    58,    59,    60,    61,    -1,
    63,    64,    65,    66,    67,    68,    69,    70,    -1,    35,
    36,    -1,    38,    39,    40,    -1,    42,    -1,    -1,    45,
    46,    47,    48,    -1,    -1,    -1,    -1,    -1,    -1,    55,
    56,    57,    58,    59,    60,    61,    -1,    63,    64,    65,
    66,    67,    68,    69,    70,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,   119,   120,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,   120
};
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "/usr/local/share/bison.simple"
/* This file comes from bison-1.28.  */

/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

#ifndef YYSTACK_USE_ALLOCA
#ifdef alloca
#define YYSTACK_USE_ALLOCA
#else /* alloca not defined */
#ifdef __GNUC__
#define YYSTACK_USE_ALLOCA
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
#define YYSTACK_USE_ALLOCA
#include <alloca.h>
#else /* not sparc */
/* We think this test detects Watcom and Microsoft C.  */
/* This used to test MSDOS, but that is a bad idea
   since that symbol is in the user namespace.  */
#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
#if 0 /* No need for malloc.h, which pollutes the namespace;
	 instead, just don't use alloca.  */
#include <malloc.h>
#endif
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
/* I don't know what this was needed for, but it pollutes the namespace.
   So I turned it off.   rms, 2 May 1997.  */
/* #include <malloc.h>  */
 #pragma alloca
#define YYSTACK_USE_ALLOCA
#else /* not MSDOS, or __TURBOC__, or _AIX */
#if 0
#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
		 and on HPUX 10.  Eventually we can turn this on.  */
#define YYSTACK_USE_ALLOCA
#define alloca __builtin_alloca
#endif /* __hpux */
#endif
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc */
#endif /* not GNU C */
#endif /* alloca not defined */
#endif /* YYSTACK_USE_ALLOCA not defined */

#ifdef YYSTACK_USE_ALLOCA
#define YYSTACK_ALLOC alloca
#else
#define YYSTACK_ALLOC malloc
#endif

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	goto yyacceptlab
#define YYABORT 	goto yyabortlab
#define YYERROR		goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (yychar == YYEMPTY && yylen == 1)				\
    { yychar = (token), yylval = (value);			\
      yychar1 = YYTRANSLATE (yychar);				\
      YYPOPSTACK;						\
      goto yybackup;						\
    }								\
  else								\
    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval, &yylloc)
#endif
#else /* not YYLSP_NEEDED */
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval)
#endif
#endif /* not YYLSP_NEEDED */
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	yychar;			/*  the lookahead symbol		*/
YYSTYPE	yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Define __yy_memcpy.  Note that the size argument
   should be passed with type unsigned int, because that is what the non-GCC
   definitions require.  With GCC, __builtin_memcpy takes an arg
   of type size_t, but it can handle unsigned int.  */

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (to, from, count)
     char *to;
     char *from;
     unsigned int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (char *to, char *from, unsigned int count)
{
  register char *t = to;
  register char *f = from;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif

#line 217 "/usr/local/share/bison.simple"

/* The user can define YYPARSE_PARAM as the name of an argument to be passed
   into yyparse.  The argument should have type void *.
   It should actually point to an object.
   Grammar actions can access the variable by casting it
   to the proper pointer type.  */

#ifdef YYPARSE_PARAM
#ifdef __cplusplus
#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#else /* not __cplusplus */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
#endif /* not __cplusplus */
#else /* not YYPARSE_PARAM */
#define YYPARSE_PARAM_ARG
#define YYPARSE_PARAM_DECL
#endif /* not YYPARSE_PARAM */

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
#ifdef YYPARSE_PARAM
int yyparse (void *);
#else
int yyparse (void);
#endif
#endif

int
yyparse(YYPARSE_PARAM_ARG)
     YYPARSE_PARAM_DECL
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *yyls = yylsa;
  YYLTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;
  int yyfree_stacks = 0;

#ifdef YYPURE
  int yychar;
  YYSTYPE yylval;
  int yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE yylloc;
#endif
#endif

  YYSTYPE yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int yylen;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YYLSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yystacksize);
#else
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YYLSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
	{
	  yyerror("parser stack overflow");
	  if (yyfree_stacks)
	    {
	      free (yyss);
	      free (yyvs);
#ifdef YYLSP_NEEDED
	      free (yyls);
#endif
	    }
	  return 2;
	}
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
	yystacksize = YYMAXDEPTH;
#ifndef YYSTACK_USE_ALLOCA
      yyfree_stacks = 1;
#endif
      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
      __yy_memcpy ((char *)yyss, (char *)yyss1,
		   size * (unsigned int) sizeof (*yyssp));
      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
		   size * (unsigned int) sizeof (*yyvsp));
#ifdef YYLSP_NEEDED
      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
      __yy_memcpy ((char *)yyls, (char *)yyls1,
		   size * (unsigned int) sizeof (*yylsp));
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
	YYABORT;
    }

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  goto yybackup;
 yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Reading a token: ");
#endif
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

#if YYDEBUG != 0
      if (yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, yychar, yylval);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (yydebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


  switch (yyn) {

case 1:
#line 140 "c51.y"
{ if (!options.lessPedantic)
                    werror(W_EMPTY_SOURCE_FILE);
        ;
    break;}
case 5:
#line 152 "c51.y"
{
                               //blockNo=0;
                             ;
    break;}
case 6:
#line 155 "c51.y"
{
                               ignoreTypedefType = 0;
                               if (yyvsp[0].sym && yyvsp[0].sym->type
                                && IS_FUNC(yyvsp[0].sym->type))
                               {
                                   /* The only legal storage classes for
                                    * a function prototype (declaration)
                                    * are extern and static. extern is the
                                    * default. Thus, if this function isn't
                                    * explicitly marked static, mark it
                                    * extern.
                                    */
                                   if (yyvsp[0].sym->etype
                                    && IS_SPEC(yyvsp[0].sym->etype)
                                    && !SPEC_STAT(yyvsp[0].sym->etype))
                                   {
                                        SPEC_EXTR(yyvsp[0].sym->etype) = 1;
                                   }
                               }
                               addSymChain (&yyvsp[0].sym);
                               allocVariables (yyvsp[0].sym) ;
                               cleanUpLevel (SymbolTab,1);
                             ;
    break;}
case 7:
#line 181 "c51.y"
{   /* function type not specified */
                                   /* assume it to be 'int'       */
                                   addDecl(yyvsp[-1].sym,0,newIntLink());
                                   yyval.asts = createFunction(yyvsp[-1].sym,yyvsp[0].asts);
                               ;
    break;}
case 8:
#line 187 "c51.y"
{
                                    pointerTypes(yyvsp[-1].sym->type,copyLinkChain(yyvsp[-2].lnk));
                                    addDecl(yyvsp[-1].sym,0,yyvsp[-2].lnk);
                                    yyval.asts = createFunction(yyvsp[-1].sym,yyvsp[0].asts);
                                ;
    break;}
case 10:
#line 196 "c51.y"
{ yyval.lnk = mergeSpec(yyvsp[-1].lnk,yyvsp[0].lnk,"function_attribute"); ;
    break;}
case 11:
#line 200 "c51.y"
{
                        yyval.lnk = newLink(SPECIFIER) ;
                        FUNC_REGBANK(yyval.lnk) = (int) ulFromVal(constExprValue(yyvsp[0].asts,TRUE));
                     ;
    break;}
case 12:
#line 204 "c51.y"
{  yyval.lnk = newLink (SPECIFIER);
                        FUNC_ISREENT(yyval.lnk)=1;
                     ;
    break;}
case 13:
#line 207 "c51.y"
{  yyval.lnk = newLink (SPECIFIER);
                        FUNC_ISCRITICAL(yyval.lnk) = 1;
                     ;
    break;}
case 14:
#line 210 "c51.y"
{  yyval.lnk = newLink (SPECIFIER);
                        FUNC_ISNAKED(yyval.lnk)=1;
                     ;
    break;}
case 15:
#line 213 "c51.y"
{  yyval.lnk = newLink (SPECIFIER);
                        FUNC_ISJAVANATIVE(yyval.lnk)=1;
                     ;
    break;}
case 16:
#line 216 "c51.y"
{  yyval.lnk = newLink (SPECIFIER);
                        FUNC_ISOVERLAY(yyval.lnk)=1;
                     ;
    break;}
case 17:
#line 219 "c51.y"
{yyval.lnk = newLink (SPECIFIER);
                        FUNC_NONBANKED(yyval.lnk) = 1;
                        if (FUNC_BANKED(yyval.lnk)) {
                            werror(W_BANKED_WITH_NONBANKED);
                        }
                     ;
    break;}
case 18:
#line 225 "c51.y"
{yyval.lnk = newLink (SPECIFIER);
                        FUNC_ISSHADOWREGS(yyval.lnk) = 1;
                     ;
    break;}
case 19:
#line 228 "c51.y"
{yyval.lnk = newLink (SPECIFIER);
                        FUNC_ISWPARAM(yyval.lnk) = 1;
                     ;
    break;}
case 20:
#line 231 "c51.y"
{yyval.lnk = newLink (SPECIFIER);
                        FUNC_BANKED(yyval.lnk) = 1;
                        if (FUNC_NONBANKED(yyval.lnk)) {
                            werror(W_BANKED_WITH_NONBANKED);
                        }
                        if (SPEC_STAT(yyval.lnk)) {
                            werror(W_BANKED_WITH_STATIC);
                        }
                     ;
    break;}
case 21:
#line 241 "c51.y"
{
                        yyval.lnk = newLink (SPECIFIER) ;
                        FUNC_INTNO(yyval.lnk) = yyvsp[0].yyint ;
                        FUNC_ISISR(yyval.lnk) = 1;
                     ;
    break;}
case 23:
#line 251 "c51.y"
{
            werror(E_OLD_STYLE,(yyvsp[-1].sym ? yyvsp[-1].sym->name: "")) ;
            exit(1);
         ;
    break;}
case 24:
#line 258 "c51.y"
{  yyval.asts = newAst_VALUE(symbolVal(yyvsp[0].sym));  ;
    break;}
case 25:
#line 259 "c51.y"
{  yyval.asts = newAst_VALUE(yyvsp[0].val);  ;
    break;}
case 27:
#line 261 "c51.y"
{  yyval.asts = yyvsp[-1].asts ;                   ;
    break;}
case 28:
#line 265 "c51.y"
{ yyval.asts = newAst_VALUE(yyvsp[0].val); ;
    break;}
case 30:
#line 270 "c51.y"
{ yyval.asts = newNode  ('[', yyvsp[-3].asts, yyvsp[-1].asts) ; ;
    break;}
case 31:
#line 271 "c51.y"
{ yyval.asts = newNode  (CALL,yyvsp[-2].asts,NULL);
                                          yyval.asts->left->funcName = 1;;
    break;}
case 32:
#line 274 "c51.y"
{
            yyval.asts = newNode  (CALL,yyvsp[-3].asts,yyvsp[-1].asts) ; yyval.asts->left->funcName = 1;
          ;
    break;}
case 33:
#line 277 "c51.y"
{ ignoreTypedefType = 1; ;
    break;}
case 34:
#line 278 "c51.y"
{
                        ignoreTypedefType = 0;
                        yyvsp[0].sym = newSymbol(yyvsp[0].sym->name,NestLevel);
                        yyvsp[0].sym->implicit = 1;
                        yyval.asts = newNode(PTR_OP,newNode('&',yyvsp[-3].asts,NULL),newAst_VALUE(symbolVal(yyvsp[0].sym)));
                      ;
    break;}
case 35:
#line 284 "c51.y"
{ ignoreTypedefType = 1; ;
    break;}
case 36:
#line 285 "c51.y"
{
                        ignoreTypedefType = 0;
                        yyvsp[0].sym = newSymbol(yyvsp[0].sym->name,NestLevel);
                        yyvsp[0].sym->implicit = 1;
                        yyval.asts = newNode(PTR_OP,yyvsp[-3].asts,newAst_VALUE(symbolVal(yyvsp[0].sym)));
                      ;
    break;}
case 37:
#line 292 "c51.y"
{ yyval.asts = newNode(INC_OP,yyvsp[-1].asts,NULL);;
    break;}
case 38:
#line 294 "c51.y"
{ yyval.asts = newNode(DEC_OP,yyvsp[-1].asts,NULL); ;
    break;}
case 40:
#line 299 "c51.y"
{ yyval.asts = newNode(PARAM,yyvsp[-2].asts,yyvsp[0].asts); ;
    break;}
case 42:
#line 304 "c51.y"
{ yyval.asts = newNode(INC_OP,NULL,yyvsp[0].asts);  ;
    break;}
case 43:
#line 305 "c51.y"
{ yyval.asts = newNode(DEC_OP,NULL,yyvsp[0].asts);  ;
    break;}
case 44:
#line 306 "c51.y"
{ yyval.asts = newNode(yyvsp[-1].yyint,yyvsp[0].asts,NULL)    ;  ;
    break;}
case 45:
#line 307 "c51.y"
{ yyval.asts = newNode(SIZEOF,NULL,yyvsp[0].asts);  ;
    break;}
case 46:
#line 308 "c51.y"
{ yyval.asts = newAst_VALUE(sizeofOp(yyvsp[-1].lnk)); ;
    break;}
case 47:
#line 309 "c51.y"
{ yyval.asts = newNode(TYPEOF,NULL,yyvsp[0].asts);  ;
    break;}
case 48:
#line 313 "c51.y"
{ yyval.yyint = '&' ;;
    break;}
case 49:
#line 314 "c51.y"
{ yyval.yyint = '*' ;;
    break;}
case 50:
#line 315 "c51.y"
{ yyval.yyint = '+' ;;
    break;}
case 51:
#line 316 "c51.y"
{ yyval.yyint = '-' ;;
    break;}
case 52:
#line 317 "c51.y"
{ yyval.yyint = '~' ;;
    break;}
case 53:
#line 318 "c51.y"
{ yyval.yyint = '!' ;;
    break;}
case 55:
#line 323 "c51.y"
{ yyval.asts = newNode(CAST,newAst_LINK(yyvsp[-2].lnk),yyvsp[0].asts); ;
    break;}
case 57:
#line 328 "c51.y"
{ yyval.asts = newNode('*',yyvsp[-2].asts,yyvsp[0].asts);;
    break;}
case 58:
#line 329 "c51.y"
{ yyval.asts = newNode('/',yyvsp[-2].asts,yyvsp[0].asts);;
    break;}
case 59:
#line 330 "c51.y"
{ yyval.asts = newNode('%',yyvsp[-2].asts,yyvsp[0].asts);;
    break;}
case 61:
#line 335 "c51.y"
{ yyval.asts=newNode('+',yyvsp[-2].asts,yyvsp[0].asts);;
    break;}
case 62:
#line 336 "c51.y"
{ yyval.asts=newNode('-',yyvsp[-2].asts,yyvsp[0].asts);;
    break;}
case 64:
#line 341 "c51.y"
{ yyval.asts = newNode(LEFT_OP,yyvsp[-2].asts,yyvsp[0].asts); ;
    break;}
case 65:
#line 342 "c51.y"
{ yyval.asts = newNode(RIGHT_OP,yyvsp[-2].asts,yyvsp[0].asts); ;
    break;}
case 67:
#line 347 "c51.y"
{ yyval.asts = newNode('<',  yyvsp[-2].asts,yyvsp[0].asts);;
    break;}
case 68:
#line 348 "c51.y"
{ yyval.asts = newNode('>',  yyvsp[-2].asts,yyvsp[0].asts);;
    break;}
case 69:
#line 349 "c51.y"
{ yyval.asts = newNode(LE_OP,yyvsp[-2].asts,yyvsp[0].asts);;
    break;}
case 70:
#line 350 "c51.y"
{ yyval.asts = newNode(GE_OP,yyvsp[-2].asts,yyvsp[0].asts);;
    break;}
case 72:
#line 355 "c51.y"
{ yyval.asts = newNode(EQ_OP,yyvsp[-2].asts,yyvsp[0].asts);;
    break;}
case 73:
#line 356 "c51.y"
{ yyval.asts = newNode(NE_OP,yyvsp[-2].asts,yyvsp[0].asts);;
    break;}
case 75:
#line 361 "c51.y"
{ yyval.asts = newNode('&',yyvsp[-2].asts,yyvsp[0].asts);;
    break;}
case 77:
#line 366 "c51.y"
{ yyval.asts = newNode('^',yyvsp[-2].asts,yyvsp[0].asts);;
    break;}
case 79:
#line 371 "c51.y"
{ yyval.asts = newNode('|',yyvsp[-2].asts,yyvsp[0].asts);;
    break;}
case 81:
#line 376 "c51.y"
{ seqPointNo++;;
    break;}
case 82:
#line 377 "c51.y"
{ yyval.asts = newNode(AND_OP,yyvsp[-3].asts,yyvsp[0].asts);;
    break;}
case 84:
#line 382 "c51.y"
{ seqPointNo++;;
    break;}
case 85:
#line 383 "c51.y"
{ yyval.asts = newNode(OR_OP,yyvsp[-3].asts,yyvsp[0].asts); ;
    break;}
case 87:
#line 388 "c51.y"
{ seqPointNo++;;
    break;}
case 88:
#line 389 "c51.y"
{
                        yyval.asts = newNode(':',yyvsp[-2].asts,yyvsp[0].asts) ;
                        yyval.asts = newNode('?',yyvsp[-5].asts,yyval.asts) ;
                     ;
    break;}
case 90:
#line 398 "c51.y"
{

                             switch (yyvsp[-1].yyint) {
                             case '=':
                                     yyval.asts = newNode(yyvsp[-1].yyint,yyvsp[-2].asts,yyvsp[0].asts);
                                     break;
                             case MUL_ASSIGN:
                                     yyval.asts = createRMW(yyvsp[-2].asts, '*', yyvsp[0].asts);
                                     break;
                             case DIV_ASSIGN:
                                     yyval.asts = createRMW(yyvsp[-2].asts, '/', yyvsp[0].asts);
                                     break;
                             case MOD_ASSIGN:
                                     yyval.asts = createRMW(yyvsp[-2].asts, '%', yyvsp[0].asts);
                                     break;
                             case ADD_ASSIGN:
                                     yyval.asts = createRMW(yyvsp[-2].asts, '+', yyvsp[0].asts);
                                     break;
                             case SUB_ASSIGN:
                                     yyval.asts = createRMW(yyvsp[-2].asts, '-', yyvsp[0].asts);
                                     break;
                             case LEFT_ASSIGN:
                                     yyval.asts = createRMW(yyvsp[-2].asts, LEFT_OP, yyvsp[0].asts);
                                     break;
                             case RIGHT_ASSIGN:
                                     yyval.asts = createRMW(yyvsp[-2].asts, RIGHT_OP, yyvsp[0].asts);
                                     break;
                             case AND_ASSIGN:
                                     yyval.asts = createRMW(yyvsp[-2].asts, '&', yyvsp[0].asts);
                                     break;
                             case XOR_ASSIGN:
                                     yyval.asts = createRMW(yyvsp[-2].asts, '^', yyvsp[0].asts);
                                     break;
                             case OR_ASSIGN:
                                     yyval.asts = createRMW(yyvsp[-2].asts, '|', yyvsp[0].asts);
                                     break;
                             default :
                                     yyval.asts = NULL;
                             }

                     ;
    break;}
case 91:
#line 442 "c51.y"
{ yyval.yyint = '=' ;;
    break;}
case 103:
#line 457 "c51.y"
{ seqPointNo++;;
    break;}
case 104:
#line 457 "c51.y"
{ yyval.asts = newNode(',',yyvsp[-3].asts,yyvsp[0].asts);;
    break;}
case 106:
#line 466 "c51.y"
{
         if (uselessDecl)
           werror(W_USELESS_DECL);
         uselessDecl = TRUE;
         yyval.sym = NULL ;
      ;
    break;}
case 107:
#line 473 "c51.y"
{
         /* add the specifier list to the id */
         symbol *sym , *sym1;

         for (sym1 = sym = reverseSyms(yyvsp[-1].sym);sym != NULL;sym = sym->next) {
             sym_link *lnk = copyLinkChain(yyvsp[-2].lnk);
             /* do the pointer stuff */
             pointerTypes(sym->type,lnk);
             addDecl (sym,0,lnk) ;
         }

         uselessDecl = TRUE;
         yyval.sym = sym1 ;
      ;
    break;}
case 108:
#line 489 "c51.y"
{ yyval.lnk = finalizeSpec(yyvsp[0].lnk); ;
    break;}
case 109:
#line 492 "c51.y"
{ yyval.lnk = yyvsp[0].lnk; ;
    break;}
case 110:
#line 493 "c51.y"
{
     /* if the decl $2 is not a specifier */
     /* find the spec and replace it      */
     yyval.lnk = mergeDeclSpec(yyvsp[-1].lnk, yyvsp[0].lnk, "storage_class_specifier declaration_specifiers - skipped");
   ;
    break;}
case 111:
#line 498 "c51.y"
{ yyval.lnk = yyvsp[0].lnk; ;
    break;}
case 112:
#line 499 "c51.y"
{
     /* if the decl $2 is not a specifier */
     /* find the spec and replace it      */
     yyval.lnk = mergeDeclSpec(yyvsp[-1].lnk, yyvsp[0].lnk, "type_specifier declaration_specifiers - skipped");
   ;
    break;}
case 113:
#line 504 "c51.y"
{ yyval.lnk = yyvsp[0].lnk; ;
    break;}
case 114:
#line 505 "c51.y"
{
     /* if the decl $2 is not a specifier */
     /* find the spec and replace it      */
     yyval.lnk = mergeDeclSpec(yyvsp[-1].lnk, yyvsp[0].lnk, "function_specifier declaration_specifiers - skipped");
   ;
    break;}
case 116:
#line 514 "c51.y"
{ yyvsp[0].sym->next = yyvsp[-2].sym ; yyval.sym = yyvsp[0].sym;;
    break;}
case 117:
#line 518 "c51.y"
{ yyvsp[0].sym->ival = NULL ; ;
    break;}
case 118:
#line 519 "c51.y"
{ yyvsp[-2].sym->ival = yyvsp[0].ilist   ; ;
    break;}
case 119:
#line 523 "c51.y"
{ yyval.dsgn = NULL; ;
    break;}
case 121:
#line 528 "c51.y"
{ yyval.dsgn = revDesignation(yyvsp[-1].dsgn); ;
    break;}
case 123:
#line 533 "c51.y"
{ yyvsp[0].dsgn->next = yyvsp[-1].dsgn; yyval.dsgn = yyvsp[0].dsgn; ;
    break;}
case 124:
#line 538 "c51.y"
{
 	  	     value *tval;
 	  	     int elemno;
 
 	  	     tval = constExprValue(yyvsp[-1].asts, TRUE);
 	  	     /* if it is not a constant then Error  */
 	  	     if (!tval || (SPEC_SCLS(tval->etype) != S_LITERAL))
 	  	       {
 	  	         werror (E_CONST_EXPECTED);
 	  	         elemno = 0; /* arbitrary fixup */
 	  	       }
 	  	     else
 	  	       {
 	  	         if ((elemno = (int) ulFromVal(tval)) < 0)
 	  	           {
 	  	             werror (E_BAD_DESIGNATOR);
 	  	             elemno = 0; /* arbitrary fixup */
 	  	           }
 	  	       }
 	  	     yyval.dsgn = newDesignation(DESIGNATOR_ARRAY, &elemno);
 	  	  ;
    break;}
case 125:
#line 559 "c51.y"
{ yyval.dsgn = newDesignation(DESIGNATOR_STRUCT,yyvsp[0].sym); ;
    break;}
case 126:
#line 564 "c51.y"
{
                  yyval.lnk = newLink (SPECIFIER) ;
                  SPEC_TYPEDEF(yyval.lnk) = 1 ;
               ;
    break;}
case 127:
#line 568 "c51.y"
{
                  yyval.lnk = newLink(SPECIFIER);
                  SPEC_EXTR(yyval.lnk) = 1 ;
               ;
    break;}
case 128:
#line 572 "c51.y"
{
                  yyval.lnk = newLink (SPECIFIER);
                  SPEC_STAT(yyval.lnk) = 1 ;
               ;
    break;}
case 129:
#line 576 "c51.y"
{
                  yyval.lnk = newLink (SPECIFIER) ;
                  SPEC_SCLS(yyval.lnk) = S_AUTO  ;
               ;
    break;}
case 130:
#line 580 "c51.y"
{
                  yyval.lnk = newLink (SPECIFIER);
                  SPEC_SCLS(yyval.lnk) = S_REGISTER ;
               ;
    break;}
case 131:
#line 587 "c51.y"
{
                  yyval.lnk = newLink (SPECIFIER) ;
                  SPEC_INLINE(yyval.lnk) = 1 ;
               ;
    break;}
case 132:
#line 594 "c51.y"
{ yyval.yyint = INTNO_UNSPEC ; ;
    break;}
case 133:
#line 596 "c51.y"
{ int intno = (int) ulFromVal(constExprValue(yyvsp[0].asts,TRUE));
          if ((intno >= 0) && (intno <= INTNO_MAX))
            yyval.yyint = intno;
          else
            {
              werror(E_INT_BAD_INTNO, intno);
              yyval.yyint = INTNO_UNSPEC;
            }
        ;
    break;}
case 135:
#line 610 "c51.y"
{
           /* add this to the storage class specifier  */
           SPEC_ABSA(yyvsp[-2].lnk) = 1;   /* set the absolute addr flag */
           /* now get the abs addr from value */
           SPEC_ADDR(yyvsp[-2].lnk) = (unsigned int) ulFromVal(constExprValue(yyvsp[0].asts,TRUE)) ;
        ;
    break;}
case 136:
#line 619 "c51.y"
{
                  yyval.lnk=newLink(SPECIFIER);
                  SPEC_NOUN(yyval.lnk) = V_CHAR  ;
                  ignoreTypedefType = 1;
               ;
    break;}
case 137:
#line 624 "c51.y"
{
                  yyval.lnk=newLink(SPECIFIER);
                  SPEC_SHORT(yyval.lnk) = 1 ;
                  ignoreTypedefType = 1;
               ;
    break;}
case 138:
#line 629 "c51.y"
{
                  yyval.lnk=newLink(SPECIFIER);
                  SPEC_NOUN(yyval.lnk) = V_INT   ;
                  ignoreTypedefType = 1;
               ;
    break;}
case 139:
#line 634 "c51.y"
{
                  yyval.lnk=newLink(SPECIFIER);
                  SPEC_LONG(yyval.lnk) = 1       ;
                  ignoreTypedefType = 1;
               ;
    break;}
case 140:
#line 639 "c51.y"
{
                  yyval.lnk=newLink(SPECIFIER);
                  yyval.lnk->select.s.b_signed = 1;
                  ignoreTypedefType = 1;
               ;
    break;}
case 141:
#line 644 "c51.y"
{
                  yyval.lnk=newLink(SPECIFIER);
                  SPEC_USIGN(yyval.lnk) = 1      ;
                  ignoreTypedefType = 1;
               ;
    break;}
case 142:
#line 649 "c51.y"
{
                  yyval.lnk=newLink(SPECIFIER);
                  SPEC_NOUN(yyval.lnk) = V_VOID  ;
                  ignoreTypedefType = 1;
               ;
    break;}
case 143:
#line 654 "c51.y"
{
                  yyval.lnk=newLink(SPECIFIER);
                  SPEC_CONST(yyval.lnk) = 1;
               ;
    break;}
case 144:
#line 658 "c51.y"
{
                  yyval.lnk=newLink(SPECIFIER);
                  SPEC_VOLATILE(yyval.lnk) = 1 ;
               ;
    break;}
case 145:
#line 662 "c51.y"
{
                  yyval.lnk=newLink(SPECIFIER);
                  SPEC_RESTRICT(yyval.lnk) = 1 ;
               ;
    break;}
case 146:
#line 666 "c51.y"
{
                  yyval.lnk=newLink(SPECIFIER);
                  SPEC_NOUN(yyval.lnk) = V_FLOAT;
                  ignoreTypedefType = 1;
               ;
    break;}
case 147:
#line 671 "c51.y"
{
                  yyval.lnk=newLink(SPECIFIER);
                  SPEC_NOUN(yyval.lnk) = V_FIXED16X16;
                  ignoreTypedefType = 1;
               ;
    break;}
case 148:
#line 676 "c51.y"
{
                  yyval.lnk = newLink (SPECIFIER);
                  SPEC_SCLS(yyval.lnk) = S_XDATA  ;
               ;
    break;}
case 149:
#line 680 "c51.y"
{
                  yyval.lnk = newLink (SPECIFIER) ;
                  SPEC_SCLS(yyval.lnk) = S_CODE ;
               ;
    break;}
case 150:
#line 684 "c51.y"
{
                  yyval.lnk = newLink (SPECIFIER) ;
                  SPEC_SCLS(yyval.lnk) = S_EEPROM ;
               ;
    break;}
case 151:
#line 688 "c51.y"
{
                  yyval.lnk = newLink (SPECIFIER);
                  SPEC_SCLS(yyval.lnk) = S_DATA   ;
               ;
    break;}
case 152:
#line 692 "c51.y"
{
                  yyval.lnk = newLink (SPECIFIER);
                  SPEC_SCLS(yyval.lnk) = S_IDATA  ;
               ;
    break;}
case 153:
#line 696 "c51.y"
{
                  yyval.lnk = newLink (SPECIFIER);
                  SPEC_SCLS(yyval.lnk) = S_PDATA  ;
               ;
    break;}
case 154:
#line 700 "c51.y"
{
                  yyval.lnk=newLink(SPECIFIER);
                  SPEC_NOUN(yyval.lnk) = V_BIT   ;
                  SPEC_SCLS(yyval.lnk) = S_BIT   ;
                  SPEC_BLEN(yyval.lnk) = 1;
                  SPEC_BSTR(yyval.lnk) = 0;
                  ignoreTypedefType = 1;
               ;
    break;}
case 155:
#line 709 "c51.y"
{
                                   uselessDecl = FALSE;
                                   yyval.lnk = yyvsp[0].lnk ;
                                   ignoreTypedefType = 1;
                                ;
    break;}
case 156:
#line 714 "c51.y"
{
                           cenum = NULL ;
                           uselessDecl = FALSE;
                           ignoreTypedefType = 1;
                           yyval.lnk = yyvsp[0].lnk ;
                        ;
    break;}
case 157:
#line 721 "c51.y"
{
            symbol *sym;
            sym_link   *p  ;
            sym = findSym(TypedefTab,NULL,yyvsp[0].yychar) ;
            yyval.lnk = p = copyLinkChain(sym ? sym->type : NULL);
            SPEC_TYPEDEF(getSpec(p)) = 0;
            ignoreTypedefType = 1;
         ;
    break;}
case 159:
#line 733 "c51.y"
{
               yyval.lnk = newLink(SPECIFIER) ;
               SPEC_NOUN(yyval.lnk) = V_SBIT;
               SPEC_SCLS(yyval.lnk) = S_SBIT;
               SPEC_BLEN(yyval.lnk) = 1;
               SPEC_BSTR(yyval.lnk) = 0;
               ignoreTypedefType = 1;
            ;
    break;}
case 161:
#line 745 "c51.y"
{
               yyval.lnk = newLink(SPECIFIER) ;
               FUNC_REGBANK(yyval.lnk) = 0;
               SPEC_NOUN(yyval.lnk)    = V_CHAR;
               SPEC_SCLS(yyval.lnk)    = S_SFR ;
               SPEC_USIGN(yyval.lnk)   = 1 ;
               ignoreTypedefType = 1;
            ;
    break;}
case 162:
#line 753 "c51.y"
{
               yyval.lnk = newLink(SPECIFIER) ;
               FUNC_REGBANK(yyval.lnk) = 1;
               SPEC_NOUN(yyval.lnk)    = V_CHAR;
               SPEC_SCLS(yyval.lnk)    = S_SFR ;
               SPEC_USIGN(yyval.lnk)   = 1 ;
               ignoreTypedefType = 1;
            ;
    break;}
case 163:
#line 764 "c51.y"
{
               yyval.lnk = newLink(SPECIFIER) ;
               FUNC_REGBANK(yyval.lnk) = 0;
               SPEC_NOUN(yyval.lnk)    = V_INT;
               SPEC_SCLS(yyval.lnk)    = S_SFR;
               SPEC_USIGN(yyval.lnk)   = 1 ;
               ignoreTypedefType = 1;
            ;
    break;}
case 164:
#line 775 "c51.y"
{
               yyval.lnk = newLink(SPECIFIER) ;
               FUNC_REGBANK(yyval.lnk) = 0;
               SPEC_NOUN(yyval.lnk)    = V_INT;
               SPEC_SCLS(yyval.lnk)    = S_SFR;
               SPEC_LONG(yyval.lnk)    = 1;
               SPEC_USIGN(yyval.lnk)   = 1;
               ignoreTypedefType = 1;
            ;
    break;}
case 165:
#line 788 "c51.y"
{
           if (!yyvsp[0].sdef->type)
             {
               yyvsp[0].sdef->type = yyvsp[-1].yyint;
             }
           else
             {
               if (yyvsp[0].sdef->type != yyvsp[-1].yyint)
                 werror(E_BAD_TAG, yyvsp[0].sdef->tag, yyvsp[-1].yyint==STRUCT ? "struct" : "union");
             }

        ;
    break;}
case 166:
#line 801 "c51.y"
{
           structdef *sdef ;
           symbol *sym, *dsym;

           // check for errors in structure members
           for (sym=yyvsp[-1].sym; sym; sym=sym->next) {
             if (IS_ABSOLUTE(sym->etype)) {
               werrorfl(sym->fileDef, sym->lineDef, E_NOT_ALLOWED, "'at'");
               SPEC_ABSA(sym->etype) = 0;
             }
             if (IS_SPEC(sym->etype) && SPEC_SCLS(sym->etype)) {
               werrorfl(sym->fileDef, sym->lineDef, E_NOT_ALLOWED, "storage class");
               printTypeChainRaw (sym->type,NULL);
               SPEC_SCLS(sym->etype) = 0;
             }
             for (dsym=sym->next; dsym; dsym=dsym->next) {
               if (*dsym->name && strcmp(sym->name, dsym->name)==0) {
                 werrorfl(sym->fileDef, sym->lineDef, E_DUPLICATE_MEMBER,
                        yyvsp[-5].yyint==STRUCT ? "struct" : "union", sym->name);
                 werrorfl(dsym->fileDef, dsym->lineDef, E_PREVIOUS_DEF);
               }
             }
           }

           /* Create a structdef   */
           sdef = yyvsp[-4].sdef ;
           sdef->fields   = reverseSyms(yyvsp[-1].sym) ;   /* link the fields */
           sdef->size  = compStructSize(yyvsp[-5].yyint,sdef);   /* update size of  */
           promoteAnonStructs (yyvsp[-5].yyint, sdef);

           /* Create the specifier */
           yyval.lnk = newLink (SPECIFIER) ;
           SPEC_NOUN(yyval.lnk) = V_STRUCT;
           SPEC_STRUCT(yyval.lnk)= sdef ;
        ;
    break;}
case 167:
#line 837 "c51.y"
{
            yyval.lnk = newLink(SPECIFIER) ;
            SPEC_NOUN(yyval.lnk) = V_STRUCT;
            SPEC_STRUCT(yyval.lnk) = yyvsp[0].sdef;

           if (!yyvsp[0].sdef->type)
             {
               yyvsp[0].sdef->type = yyvsp[-1].yyint;
             }
           else
             {
               if (yyvsp[0].sdef->type != yyvsp[-1].yyint)
                 werror(E_BAD_TAG, yyvsp[0].sdef->tag, yyvsp[-1].yyint==STRUCT ? "struct" : "union");
             }
         ;
    break;}
case 168:
#line 855 "c51.y"
{ yyval.yyint = STRUCT ;  ignoreTypedefType = 1; ;
    break;}
case 169:
#line 856 "c51.y"
{ yyval.yyint = UNION  ;  ignoreTypedefType = 1; ;
    break;}
case 171:
#line 861 "c51.y"
{  /* synthesize a name add to structtable */
	 ignoreTypedefType = 0;
     yyval.sdef = newStruct(genSymName(NestLevel)) ;
     yyval.sdef->level = NestLevel ;
     addSym (StructTab, yyval.sdef, yyval.sdef->tag,yyval.sdef->level,currBlockno, 0);
;
    break;}
case 172:
#line 869 "c51.y"
{  /* add name to structure table */
	 ignoreTypedefType = 0;
     yyval.sdef = findSymWithBlock (StructTab,yyvsp[0].sym,currBlockno);
     if (! yyval.sdef ) {
       yyval.sdef = newStruct(yyvsp[0].sym->name) ;
       yyval.sdef->level = NestLevel ;
       addSym (StructTab, yyval.sdef, yyval.sdef->tag,yyval.sdef->level,currBlockno,0);
     }
;
    break;}
case 174:
#line 883 "c51.y"
{
           symbol *sym=yyvsp[0].sym;

           /* go to the end of the chain */
           while (sym->next) sym=sym->next;
           sym->next = yyvsp[-1].sym ;

           yyval.sym = yyvsp[0].sym;
       ;
    break;}
case 175:
#line 896 "c51.y"
{
           /* add this type to all the symbols */
           symbol *sym ;
           for ( sym = yyvsp[-1].sym ; sym != NULL ; sym = sym->next ) {
               sym_link *btype = copyLinkChain(yyvsp[-2].lnk);

               pointerTypes(sym->type,btype);
               if (!sym->type) {
                   sym->type = btype;
                   sym->etype = getSpec(sym->type);
               }
               else
                 addDecl (sym,0,btype);
               /* make sure the type is complete and sane */
               checkTypeSanity(sym->etype, sym->name);
           }
           ignoreTypedefType = 0;
           yyval.sym = yyvsp[-1].sym;
       ;
    break;}
case 177:
#line 920 "c51.y"
{
           yyvsp[0].sym->next  = yyvsp[-2].sym ;
           yyval.sym = yyvsp[0].sym ;
       ;
    break;}
case 179:
#line 928 "c51.y"
{
                           unsigned int bitsize;
                           yyval.sym = newSymbol (genSymName(NestLevel),NestLevel) ;
                           bitsize = (unsigned int) ulFromVal(constExprValue(yyvsp[0].asts,TRUE));
                           if (bitsize > (port->s.int_size * 8)) {
                             bitsize = port->s.int_size * 8;
                             werror(E_BITFLD_SIZE, bitsize);
                           }
                           if (!bitsize)
                             bitsize = BITVAR_PAD;
                           yyval.sym->bitVar = bitsize;
                           yyval.sym->bitUnnamed = 1;
                        ;
    break;}
case 180:
#line 942 "c51.y"
{
                          unsigned int bitsize;
                          bitsize = (unsigned int) ulFromVal(constExprValue(yyvsp[0].asts,TRUE));
                          if (bitsize > (port->s.int_size * 8)) {
                            bitsize = port->s.int_size * 8;
                            werror(E_BITFLD_SIZE, bitsize);
                          }
                          if (!bitsize) {
                            yyval.sym = newSymbol (genSymName(NestLevel),NestLevel) ;
                            yyval.sym->bitVar = BITVAR_PAD;
                            werror(W_BITFLD_NAMED);
                          }
                          else
                            yyvsp[-2].sym->bitVar = bitsize;
                        ;
    break;}
case 181:
#line 957 "c51.y"
{ yyval.sym = newSymbol ("", NestLevel) ; ;
    break;}
case 182:
#line 962 "c51.y"
{
           yyval.lnk = newEnumType (yyvsp[-1].sym);       //copyLinkChain(cenum->type);
           SPEC_SCLS(getSpec(yyval.lnk)) = 0;
         ;
    break;}
case 183:
#line 967 "c51.y"
{
     symbol *csym ;
     sym_link *enumtype;

     csym = findSymWithLevel(enumTab, yyvsp[-3].sym);
     if ((csym && csym->level == yyvsp[-3].sym->level))
       {
         werrorfl(yyvsp[-3].sym->fileDef, yyvsp[-3].sym->lineDef, E_DUPLICATE_TYPEDEF,csym->name);
         werrorfl(csym->fileDef, csym->lineDef, E_PREVIOUS_DEF);
       }

     enumtype = newEnumType (yyvsp[-1].sym);       //copyLinkChain(cenum->type);
     SPEC_SCLS(getSpec(enumtype)) = 0;
     yyvsp[-3].sym->type = enumtype;

     /* add this to the enumerator table */
     if (!csym)
       addSym ( enumTab,yyvsp[-3].sym,yyvsp[-3].sym->name,yyvsp[-3].sym->level,yyvsp[-3].sym->block, 0);
     yyval.lnk = copyLinkChain(enumtype);
   ;
    break;}
case 184:
#line 987 "c51.y"
{
     symbol *csym ;

     /* check the enumerator table */
      if ((csym = findSymWithLevel(enumTab, yyvsp[0].sym)))
       yyval.lnk = copyLinkChain(csym->type);
     else  {
       yyval.lnk = newLink(SPECIFIER) ;
       SPEC_NOUN(yyval.lnk) = V_INT   ;
     }
   ;
    break;}
case 187:
#line 1004 "c51.y"
{
        yyvsp[0].sym->next = yyvsp[-2].sym ;
        yyval.sym = yyvsp[0].sym  ;
      ;
    break;}
case 188:
#line 1012 "c51.y"
{
        symbol *sym;

        // check if the symbol at the same level already exists
        if ((sym = findSymWithLevel (SymbolTab, yyvsp[-1].sym)) &&
          sym->level == yyvsp[-1].sym->level)
          {
            werrorfl (yyvsp[-1].sym->fileDef, yyvsp[-1].sym->lineDef, E_DUPLICATE_MEMBER, "enum", yyvsp[-1].sym->name);
            werrorfl (sym->fileDef, sym->lineDef, E_PREVIOUS_DEF);
          }
        yyvsp[-1].sym->type = copyLinkChain (yyvsp[0].val->type);
        yyvsp[-1].sym->etype= getSpec (yyvsp[-1].sym->type);
        SPEC_ENUM (yyvsp[-1].sym->etype) = 1;
        yyval.sym = yyvsp[-1].sym ;
        // do this now, so we can use it for the next enums in the list
        addSymChain (&yyvsp[-1].sym);
      ;
    break;}
case 189:
#line 1032 "c51.y"
{
                              value *val ;

                              val = constExprValue(yyvsp[0].asts,TRUE);
                              if (!IS_INT(val->type) && !IS_CHAR(val->type))
                                {
                                  werror(E_ENUM_NON_INTEGER);
                                  SNPRINTF(lbuff, sizeof(lbuff),
                                          "%d", (int) ulFromVal(val));
                                  val = constVal(lbuff);
                                }
                              yyval.val = cenum = val ;
                           ;
    break;}
case 190:
#line 1045 "c51.y"
{
                              if (cenum)  {
                                 SNPRINTF(lbuff, sizeof(lbuff),
                                          "%d", (int) ulFromVal(cenum)+1);
                                 yyval.val = cenum = constVal(lbuff);
                              }
                              else {
                                 yyval.val = cenum = constCharVal(0);
                              }
                           ;
    break;}
case 191:
#line 1058 "c51.y"
{ yyval.sym = yyvsp[0].sym ; ;
    break;}
case 192:
#line 1060 "c51.y"
{
             addDecl (yyvsp[0].sym,0,reverseLink(yyvsp[-1].lnk));
             yyval.sym = yyvsp[0].sym ;
         ;
    break;}
case 193:
#line 1067 "c51.y"
{ yyval.sym = yyvsp[0].sym ; ;
    break;}
case 194:
#line 1068 "c51.y"
{ yyval.sym = yyvsp[0].sym ; ;
    break;}
case 195:
#line 1072 "c51.y"
{ yyval.sym = yyvsp[0].sym; ;
    break;}
case 196:
#line 1074 "c51.y"
{
             addDecl (yyvsp[0].sym,0,reverseLink(yyvsp[-1].lnk));
             yyval.sym = yyvsp[0].sym ;
         ;
    break;}
case 197:
#line 1081 "c51.y"
{ yyval.sym = yyvsp[0].sym ; ;
    break;}
case 198:
#line 1082 "c51.y"
{
           // copy the functionAttributes (not the args and hasVargs !!)
           struct value *args;
           unsigned hasVargs;
           sym_link *funcType=yyvsp[-1].sym->type;

           while (funcType && !IS_FUNC(funcType))
             funcType = funcType->next;

           if (!funcType)
             werror (E_FUNC_ATTR);
           else
             {
               args=FUNC_ARGS(funcType);
               hasVargs=FUNC_HASVARARGS(funcType);

               memcpy (&funcType->funcAttrs, &yyvsp[0].lnk->funcAttrs,
                   sizeof(yyvsp[0].lnk->funcAttrs));

               FUNC_ARGS(funcType)=args;
               FUNC_HASVARARGS(funcType)=hasVargs;

               // just to be sure
               memset (&yyvsp[0].lnk->funcAttrs, 0,
                   sizeof(yyvsp[0].lnk->funcAttrs));

               addDecl (yyvsp[-1].sym,0,yyvsp[0].lnk);
             }
   ;
    break;}
case 200:
#line 1115 "c51.y"
{ yyval.sym = yyvsp[-1].sym; ;
    break;}
case 201:
#line 1117 "c51.y"
{
            sym_link   *p;

            p = newLink (DECLARATOR);
            DCL_TYPE(p) = ARRAY ;
            DCL_ELEM(p) = 0     ;
            addDecl(yyvsp[-2].sym,0,p);
         ;
    break;}
case 202:
#line 1126 "c51.y"
{
            sym_link *p;
            value *tval;
            int size;

            tval = constExprValue(yyvsp[-1].asts, TRUE);
            /* if it is not a constant then Error  */
            p = newLink (DECLARATOR);
            DCL_TYPE(p) = ARRAY;

            if (!tval || (SPEC_SCLS(tval->etype) != S_LITERAL))
              {
                werror(E_CONST_EXPECTED);
                /* Assume a single item array to limit the cascade */
                /* of additional errors. */
                size = 1;
              }
            else
              {
                if ((size = (int) ulFromVal(tval)) < 0)
                  {
                    werror(E_NEGATIVE_ARRAY_SIZE, yyvsp[-3].sym->name);
                    size = 1;
                  }
              }
            DCL_ELEM(p) = size;
            addDecl(yyvsp[-3].sym, 0, p);
         ;
    break;}
case 203:
#line 1157 "c51.y"
{  addDecl (yyvsp[-2].sym,FUNCTION,NULL) ;   ;
    break;}
case 204:
#line 1158 "c51.y"
{ NestLevel++ ; STACK_PUSH(blockNum, currBlockno); currBlockno = ++blockNo; ;
    break;}
case 205:
#line 1160 "c51.y"
{
             sym_link *funcType;

             addDecl (yyvsp[-4].sym,FUNCTION,NULL) ;

             funcType = yyvsp[-4].sym->type;
             while (funcType && !IS_FUNC(funcType))
               funcType = funcType->next;

             assert (funcType);

             FUNC_HASVARARGS(funcType) = IS_VARG(yyvsp[-1].val);
             FUNC_ARGS(funcType) = reverseVal(yyvsp[-1].val);

             /* nest level was incremented to take care of the parms  */
             NestLevel-- ;
             currBlockno = STACK_POP(blockNum);

             // if this was a pointer (to a function)
             if (!IS_FUNC(yyvsp[-4].sym->type))
               cleanUpLevel(SymbolTab,NestLevel+1);

             yyval.sym = yyvsp[-4].sym;
         ;
    break;}
case 206:
#line 1185 "c51.y"
{
           werror(E_OLD_STYLE,yyvsp[-3].sym->name) ;
           /* assume it returns an int */
           yyvsp[-3].sym->type = yyvsp[-3].sym->etype = newIntLink();
           yyval.sym = yyvsp[-3].sym ;
         ;
    break;}
case 207:
#line 1194 "c51.y"
{ yyval.lnk = yyvsp[0].lnk ;;
    break;}
case 208:
#line 1196 "c51.y"
{
             yyval.lnk = yyvsp[-1].lnk  ;
             if (IS_SPEC(yyvsp[0].lnk)) {
                 DCL_TSPEC(yyvsp[-1].lnk) = yyvsp[0].lnk;
                 DCL_PTR_CONST(yyvsp[-1].lnk) = SPEC_CONST(yyvsp[0].lnk);
                 DCL_PTR_VOLATILE(yyvsp[-1].lnk) = SPEC_VOLATILE(yyvsp[0].lnk);
                 DCL_PTR_RESTRICT(yyvsp[-1].lnk) = SPEC_RESTRICT(yyvsp[0].lnk);
             }
             else
                 werror (W_PTR_TYPE_INVALID);
         ;
    break;}
case 209:
#line 1208 "c51.y"
{
             yyval.lnk = yyvsp[-1].lnk ;
             yyval.lnk->next = yyvsp[0].lnk ;
             DCL_TYPE(yyvsp[0].lnk)=port->unqualified_pointer;
         ;
    break;}
case 210:
#line 1214 "c51.y"
{
             yyval.lnk = yyvsp[-2].lnk ;
             if (IS_SPEC(yyvsp[-1].lnk) && DCL_TYPE(yyvsp[0].lnk) == UPOINTER) {
                 DCL_PTR_CONST(yyvsp[-2].lnk) = SPEC_CONST(yyvsp[-1].lnk);
                 DCL_PTR_VOLATILE(yyvsp[-2].lnk) = SPEC_VOLATILE(yyvsp[-1].lnk);
                 DCL_PTR_RESTRICT(yyvsp[-2].lnk) = SPEC_RESTRICT(yyvsp[-1].lnk);
                 switch (SPEC_SCLS(yyvsp[-1].lnk)) {
                 case S_XDATA:
                     DCL_TYPE(yyvsp[0].lnk) = FPOINTER;
                     break;
                 case S_IDATA:
                     DCL_TYPE(yyvsp[0].lnk) = IPOINTER ;
                     break;
                 case S_PDATA:
                     DCL_TYPE(yyvsp[0].lnk) = PPOINTER ;
                     break;
                 case S_DATA:
                     DCL_TYPE(yyvsp[0].lnk) = POINTER ;
                     break;
                 case S_CODE:
                     DCL_TYPE(yyvsp[0].lnk) = CPOINTER ;
                     break;
                 case S_EEPROM:
                     DCL_TYPE(yyvsp[0].lnk) = EEPPOINTER;
                     break;
                 default:
                   // this could be just "constant"
                   // werror(W_PTR_TYPE_INVALID);
                     ;
                 }
             }
             else
                 werror (W_PTR_TYPE_INVALID);
             yyval.lnk->next = yyvsp[0].lnk ;
         ;
    break;}
case 211:
#line 1253 "c51.y"
{
        yyval.lnk = newLink(DECLARATOR);
        DCL_TYPE(yyval.lnk)=UPOINTER;
      ;
    break;}
case 212:
#line 1259 "c51.y"
{ yyval.lnk = finalizeSpec(yyvsp[0].lnk); ;
    break;}
case 214:
#line 1264 "c51.y"
{
     /* if the decl $2 is not a specifier */
     /* find the spec and replace it      */
     yyval.lnk = mergeDeclSpec(yyvsp[-1].lnk, yyvsp[0].lnk, "type_specifier_list type_specifier skipped");
   ;
    break;}
case 216:
#line 1274 "c51.y"
{
           yyvsp[0].sym->next = yyvsp[-2].sym;
           yyval.sym = yyvsp[0].sym ;
         ;
    break;}
case 218:
#line 1282 "c51.y"
{ yyvsp[-2].val->vArgs = 1;;
    break;}
case 220:
#line 1288 "c51.y"
{
            yyvsp[0].val->next = yyvsp[-2].val ;
            yyval.val = yyvsp[0].val ;
         ;
    break;}
case 221:
#line 1296 "c51.y"
{
                  symbol *loop ;
                  pointerTypes(yyvsp[0].sym->type,yyvsp[-1].lnk);
                  addDecl (yyvsp[0].sym,0,yyvsp[-1].lnk);
                  for (loop=yyvsp[0].sym;loop;loop->_isparm=1,loop=loop->next);
                  addSymChain (&yyvsp[0].sym);
                  yyval.val = symbolVal(yyvsp[0].sym);
                  ignoreTypedefType = 0;
               ;
    break;}
case 222:
#line 1305 "c51.y"
{
                  yyval.val = newValue() ;
                  yyval.val->type = yyvsp[0].lnk;
                  yyval.val->etype = getSpec(yyval.val->type);
                  ignoreTypedefType = 0;
               ;
    break;}
case 223:
#line 1314 "c51.y"
{ yyval.lnk = yyvsp[0].lnk; ignoreTypedefType = 0;;
    break;}
case 224:
#line 1316 "c51.y"
{
                 /* go to the end of the list */
                 sym_link *p;
                 pointerTypes(yyvsp[0].lnk,yyvsp[-1].lnk);
                 for ( p = yyvsp[0].lnk ; p && p->next ; p=p->next);
                 if (!p) {
                   werror(E_SYNTAX_ERROR, yytext);
                 } else {
                   p->next = yyvsp[-1].lnk ;
                 }
                 yyval.lnk = yyvsp[0].lnk ;
                 ignoreTypedefType = 0;
               ;
    break;}
case 225:
#line 1332 "c51.y"
{ yyval.lnk = reverseLink(yyvsp[0].lnk); ;
    break;}
case 227:
#line 1334 "c51.y"
{ yyvsp[-1].lnk = reverseLink(yyvsp[-1].lnk); yyvsp[-1].lnk->next = yyvsp[0].lnk ; yyval.lnk = yyvsp[-1].lnk;
          if (IS_PTR(yyvsp[-1].lnk) && IS_FUNC(yyvsp[0].lnk))
            DCL_TYPE(yyvsp[-1].lnk) = CPOINTER;
        ;
    break;}
case 228:
#line 1341 "c51.y"
{ yyval.lnk = yyvsp[-1].lnk ; ;
    break;}
case 229:
#line 1342 "c51.y"
{
                                       yyval.lnk = newLink (DECLARATOR);
                                       DCL_TYPE(yyval.lnk) = ARRAY ;
                                       DCL_ELEM(yyval.lnk) = 0     ;
                                    ;
    break;}
case 230:
#line 1347 "c51.y"
{
                                       value *val ;
                                       yyval.lnk = newLink (DECLARATOR);
                                       DCL_TYPE(yyval.lnk) = ARRAY ;
                                       DCL_ELEM(yyval.lnk) = (int) ulFromVal(val = constExprValue(yyvsp[-1].asts,TRUE));
                                    ;
    break;}
case 231:
#line 1353 "c51.y"
{
                                       yyval.lnk = newLink (DECLARATOR);
                                       DCL_TYPE(yyval.lnk) = ARRAY ;
                                       DCL_ELEM(yyval.lnk) = 0     ;
                                       yyval.lnk->next = yyvsp[-2].lnk ;
                                    ;
    break;}
case 232:
#line 1360 "c51.y"
{
                                       value *val ;
                                       yyval.lnk = newLink (DECLARATOR);
                                       DCL_TYPE(yyval.lnk) = ARRAY ;
                                       DCL_ELEM(yyval.lnk) = (int) ulFromVal(val = constExprValue(yyvsp[-1].asts,TRUE));
                                       yyval.lnk->next = yyvsp[-3].lnk ;
                                    ;
    break;}
case 233:
#line 1367 "c51.y"
{ yyval.lnk = NULL;;
    break;}
case 234:
#line 1368 "c51.y"
{ yyval.lnk = NULL;;
    break;}
case 235:
#line 1369 "c51.y"
{
     // $1 must be a pointer to a function
     sym_link *p=newLink(DECLARATOR);
     DCL_TYPE(p) = FUNCTION;
     if (!yyvsp[-2].lnk) {
       // ((void (code *) ()) 0) ()
       yyvsp[-2].lnk=newLink(DECLARATOR);
       DCL_TYPE(yyvsp[-2].lnk)=CPOINTER;
       yyval.lnk = yyvsp[-2].lnk;
     }
     yyvsp[-2].lnk->next=p;
   ;
    break;}
case 236:
#line 1381 "c51.y"
{ NestLevel++ ; STACK_PUSH(blockNum, currBlockno); currBlockno = ++blockNo; ;
    break;}
case 237:
#line 1381 "c51.y"
{
       sym_link *p=newLink(DECLARATOR);
       DCL_TYPE(p) = FUNCTION;

       FUNC_HASVARARGS(p) = IS_VARG(yyvsp[-1].val);
       FUNC_ARGS(p) = reverseVal(yyvsp[-1].val);

       /* nest level was incremented to take care of the parms  */
       NestLevel-- ;
       currBlockno = STACK_POP(blockNum);
       if (!yyvsp[-4].lnk) {
         /* ((void (code *) (void)) 0) () */
         yyvsp[-4].lnk=newLink(DECLARATOR);
         DCL_TYPE(yyvsp[-4].lnk)=CPOINTER;
         yyval.lnk = yyvsp[-4].lnk;
       }
       yyvsp[-4].lnk->next=p;

       // remove the symbol args (if any)
       //cleanUpLevel(SymbolTab,NestLevel+1);  // disabled to fix bug 3190029
   ;
    break;}
case 238:
#line 1405 "c51.y"
{ yyval.ilist = newiList(INIT_NODE,yyvsp[0].asts); ;
    break;}
case 239:
#line 1406 "c51.y"
{ yyval.ilist = newiList(INIT_DEEP,revinit(yyvsp[-1].ilist)); ;
    break;}
case 240:
#line 1407 "c51.y"
{ yyval.ilist = newiList(INIT_DEEP,revinit(yyvsp[-2].ilist)); ;
    break;}
case 241:
#line 1411 "c51.y"
{ yyvsp[0].ilist->designation = yyvsp[-1].dsgn; yyval.ilist = yyvsp[0].ilist; ;
    break;}
case 242:
#line 1413 "c51.y"
{
 	  	    yyvsp[0].ilist->designation = yyvsp[-1].dsgn;
 	  	    yyvsp[0].ilist->next = yyvsp[-3].ilist;
 	  	    yyval.ilist = yyvsp[0].ilist;
 	  	 ;
    break;}
case 250:
#line 1428 "c51.y"
{
                            ast *ex;
                            seqPointNo++;
                            ex = newNode(INLINEASM,NULL,NULL);
                            ex->values.inlineasm = strdup(yyvsp[-1].yyinline);
                            seqPointNo++;
                            yyval.asts = ex;
                         ;
    break;}
case 251:
#line 1439 "c51.y"
{
                   inCritical++;
                   STACK_PUSH(continueStack,NULL);
                   STACK_PUSH(breakStack,NULL);
                   yyval.sym = NULL;
                ;
    break;}
case 252:
#line 1448 "c51.y"
{
                   STACK_POP(breakStack);
                   STACK_POP(continueStack);
                   inCritical--;
                   yyval.asts = newNode(CRITICAL,yyvsp[0].asts,NULL);
                ;
    break;}
case 253:
#line 1458 "c51.y"
{  yyval.asts = createLabel(yyvsp[-1].sym,NULL);
                                          yyvsp[-1].sym->isitmp = 0;  ;
    break;}
case 254:
#line 1461 "c51.y"
{
       if (STACK_EMPTY(swStk))
         yyval.asts = createCase(NULL,yyvsp[-1].asts,NULL);
       else
         yyval.asts = createCase(STACK_PEEK(swStk),yyvsp[-1].asts,NULL);
     ;
    break;}
case 255:
#line 1467 "c51.y"
{ yyval.asts = newNode(DEFAULT,NULL,NULL); ;
    break;}
case 256:
#line 1468 "c51.y"
{
       if (STACK_EMPTY(swStk))
         yyval.asts = createDefault(NULL,yyvsp[-1].asts,NULL);
       else
         yyval.asts = createDefault(STACK_PEEK(swStk),yyvsp[-1].asts,NULL);
     ;
    break;}
case 257:
#line 1477 "c51.y"
{
				NestLevel++;
                STACK_PUSH(blockNum,currBlockno);
                currBlockno = ++blockNo ;
                ignoreTypedefType = 0;
              ;
    break;}
case 258:
#line 1485 "c51.y"
{ NestLevel--; currBlockno = STACK_POP(blockNum); EmptyIF=0;;
    break;}
case 259:
#line 1489 "c51.y"
{ yyval.asts = createBlock(NULL, NULL); ;
    break;}
case 260:
#line 1490 "c51.y"
{ yyval.asts = createBlock(NULL, yyvsp[-1].asts); ;
    break;}
case 261:
#line 1491 "c51.y"
{ yyval.asts = createBlock(yyvsp[-1].sym, NULL); ;
    break;}
case 262:
#line 1494 "c51.y"
{yyval.asts = createBlock(yyvsp[-2].sym, yyvsp[-1].asts); ;
    break;}
case 263:
#line 1495 "c51.y"
{ yyval.asts = NULL ; ;
    break;}
case 264:
#line 1500 "c51.y"
{
       /* if this is typedef declare it immediately */
       if ( yyvsp[0].sym && IS_TYPEDEF(yyvsp[0].sym->etype)) {
         allocVariables (yyvsp[0].sym);
         yyval.sym = NULL ;
       }
       else
         yyval.sym = yyvsp[0].sym ;
       ignoreTypedefType = 0;
       addSymChain(&yyvsp[0].sym);
     ;
    break;}
case 265:
#line 1513 "c51.y"
{
       symbol   *sym;

       /* if this is a typedef */
       if (yyvsp[0].sym && IS_TYPEDEF(yyvsp[0].sym->etype)) {
         allocVariables (yyvsp[0].sym);
         yyval.sym = yyvsp[-1].sym ;
       }
       else {
         /* get to the end of the previous decl */
         if ( yyvsp[-1].sym ) {
           yyval.sym = sym = yyvsp[-1].sym ;
           while (sym->next)
             sym = sym->next ;
           sym->next = yyvsp[0].sym;
         }
         else
           yyval.sym = yyvsp[0].sym ;
       }
       ignoreTypedefType = 0;
       addSymChain(&yyvsp[0].sym);
     ;
    break;}
case 267:
#line 1539 "c51.y"
{  yyval.asts = newNode(NULLOP,yyvsp[-1].asts,yyvsp[0].asts) ;;
    break;}
case 268:
#line 1543 "c51.y"
{ yyval.asts = NULL; EmptyIF=1; ;
    break;}
case 269:
#line 1544 "c51.y"
{ yyval.asts = yyvsp[-1].asts; EmptyIF=0; seqPointNo++;;
    break;}
case 270:
#line 1548 "c51.y"
{ yyval.asts = yyvsp[0].asts  ; ;
    break;}
case 271:
#line 1549 "c51.y"
{ yyval.asts = NULL;;
    break;}
case 272:
#line 1554 "c51.y"
{ seqPointNo++;;
    break;}
case 273:
#line 1555 "c51.y"
{
                              noLineno++ ;
                              yyval.asts = createIf (yyvsp[-4].asts, yyvsp[-1].asts, yyvsp[0].asts );
                              yyval.asts->lineno = yyvsp[-4].asts->lineno;
                              yyval.asts->filename = yyvsp[-4].asts->filename;
                              noLineno--;
							  if (EmptyIF==1) werrorfl(yyvsp[-4].asts->filename, yyvsp[-4].asts->lineno, W_EMPTY_IF_STATEMENT);
                           ;
    break;}
case 274:
#line 1563 "c51.y"
{
                              ast *ex ;
                              static   int swLabel = 0 ;

                              seqPointNo++;
                              /* create a node for expression  */
                              ex = newNode(SWITCH,yyvsp[-1].asts,NULL);
                              STACK_PUSH(swStk,ex);   /* save it in the stack */
                              ex->values.switchVals.swNum = swLabel ;

                              /* now create the label */
                              SNPRINTF(lbuff, sizeof(lbuff),
                                       "_swBrk_%d",swLabel++);
                              yyval.sym  =  newSymbol(lbuff,NestLevel);
                              /* put label in the break stack  */
                              STACK_PUSH(breakStack,yyval.sym);
                           ;
    break;}
case 275:
#line 1580 "c51.y"
{
                              /* get back the switch form the stack  */
                              yyval.asts = STACK_POP(swStk)  ;
                              yyval.asts->right = newNode (NULLOP,yyvsp[0].asts,createLabel(yyvsp[-1].sym,NULL));
                              STACK_POP(breakStack);
                           ;
    break;}
case 276:
#line 1588 "c51.y"
{  /* create and push the continue , break & body labels */
                  static int Lblnum = 0 ;
                  /* continue */
                  SNPRINTF (lbuff, sizeof(lbuff), "_whilecontinue_%d",Lblnum);
                  STACK_PUSH(continueStack,newSymbol(lbuff,NestLevel));
                  /* break */
                  SNPRINTF (lbuff, sizeof(lbuff), "_whilebreak_%d",Lblnum);
                  STACK_PUSH(breakStack,newSymbol(lbuff,NestLevel));
                  /* body */
                  SNPRINTF (lbuff, sizeof(lbuff), "_whilebody_%d",Lblnum++);
                  yyval.sym = newSymbol(lbuff,NestLevel);
               ;
    break;}
case 277:
#line 1602 "c51.y"
{  /* create and push the continue , break & body Labels */
           static int Lblnum = 0 ;

           /* continue */
           SNPRINTF(lbuff, sizeof(lbuff), "_docontinue_%d",Lblnum);
           STACK_PUSH(continueStack,newSymbol(lbuff,NestLevel));
           /* break */
           SNPRINTF(lbuff, sizeof(lbuff), "_dobreak_%d",Lblnum);
           STACK_PUSH(breakStack,newSymbol(lbuff,NestLevel));
           /* do body */
           SNPRINTF(lbuff, sizeof(lbuff), "_dobody_%d",Lblnum++);
           yyval.sym = newSymbol (lbuff,NestLevel);
        ;
    break;}
case 278:
#line 1617 "c51.y"
{ /* create & push continue, break & body labels */
            static int Lblnum = 0 ;

            /* continue */
            SNPRINTF(lbuff, sizeof(lbuff), "_forcontinue_%d",Lblnum);
            STACK_PUSH(continueStack,newSymbol(lbuff,NestLevel));
            /* break    */
            SNPRINTF(lbuff, sizeof(lbuff), "_forbreak_%d",Lblnum);
            STACK_PUSH(breakStack,newSymbol(lbuff,NestLevel));
            /* body */
            SNPRINTF(lbuff, sizeof(lbuff), "_forbody_%d",Lblnum);
            yyval.sym = newSymbol(lbuff,NestLevel);
            /* condition */
            SNPRINTF(lbuff, sizeof(lbuff), "_forcond_%d",Lblnum++);
            STACK_PUSH(forStack,newSymbol(lbuff,NestLevel));
          ;
    break;}
case 279:
#line 1636 "c51.y"
{ seqPointNo++;;
    break;}
case 280:
#line 1637 "c51.y"
{
                           noLineno++ ;
                           yyval.asts = createWhile ( yyvsp[-5].sym, STACK_POP(continueStack),
                                              STACK_POP(breakStack), yyvsp[-3].asts, yyvsp[0].asts );
                           yyval.asts->lineno = yyvsp[-5].sym->lineDef;
                           yyval.asts->filename = yyvsp[-5].sym->fileDef;
                           noLineno-- ;
                         ;
    break;}
case 281:
#line 1646 "c51.y"
{
                          seqPointNo++;
                          noLineno++ ;
                          yyval.asts = createDo ( yyvsp[-6].sym , STACK_POP(continueStack),
                                          STACK_POP(breakStack), yyvsp[-2].asts, yyvsp[-5].asts);
                          yyval.asts->lineno = yyvsp[-6].sym->lineDef;
                          yyval.asts->filename = yyvsp[-6].sym->fileDef;
                          noLineno-- ;
                        ;
    break;}
case 282:
#line 1656 "c51.y"
{
                          noLineno++ ;

                          /* if break or continue statement present
                             then create a general case loop */
                          if (STACK_PEEK(continueStack)->isref ||
                              STACK_PEEK(breakStack)->isref) {
                              yyval.asts = createFor (yyvsp[-8].sym, STACK_POP(continueStack),
                                              STACK_POP(breakStack) ,
                                              STACK_POP(forStack)   ,
                                              yyvsp[-6].asts , yyvsp[-4].asts , yyvsp[-2].asts, yyvsp[0].asts );
                          } else {
                              yyval.asts = newNode(FOR,yyvsp[0].asts,NULL);
                              AST_FOR(yyval.asts,trueLabel) = yyvsp[-8].sym;
                              AST_FOR(yyval.asts,continueLabel) =  STACK_POP(continueStack);
                              AST_FOR(yyval.asts,falseLabel) = STACK_POP(breakStack);
                              AST_FOR(yyval.asts,condLabel)  = STACK_POP(forStack)  ;
                              AST_FOR(yyval.asts,initExpr)   = yyvsp[-6].asts;
                              AST_FOR(yyval.asts,condExpr)   = yyvsp[-4].asts;
                              AST_FOR(yyval.asts,loopExpr)   = yyvsp[-2].asts;
                          }

                          noLineno-- ;
                        ;
    break;}
case 283:
#line 1683 "c51.y"
{ yyval.asts = NULL ; seqPointNo++; ;
    break;}
case 284:
#line 1684 "c51.y"
{ yyval.asts = yyvsp[0].asts ; seqPointNo++; ;
    break;}
case 285:
#line 1688 "c51.y"
{
                              yyvsp[-1].sym->islbl = 1;
                              yyval.asts = newAst_VALUE(symbolVal(yyvsp[-1].sym));
                              yyval.asts = newNode(GOTO,yyval.asts,NULL);
                           ;
    break;}
case 286:
#line 1693 "c51.y"
{
       /* make sure continue is in context */
       if (STACK_EMPTY(continueStack) || STACK_PEEK(continueStack) == NULL) {
           werror(E_BREAK_CONTEXT);
           yyval.asts = NULL;
       }
       else {
           yyval.asts = newAst_VALUE(symbolVal(STACK_PEEK(continueStack)));
           yyval.asts = newNode(GOTO,yyval.asts,NULL);
           /* mark the continue label as referenced */
           STACK_PEEK(continueStack)->isref = 1;
       }
   ;
    break;}
case 287:
#line 1706 "c51.y"
{
       if (STACK_EMPTY(breakStack) || STACK_PEEK(breakStack) == NULL) {
           werror(E_BREAK_CONTEXT);
           yyval.asts = NULL;
       } else {
           yyval.asts = newAst_VALUE(symbolVal(STACK_PEEK(breakStack)));
           yyval.asts = newNode(GOTO,yyval.asts,NULL);
           STACK_PEEK(breakStack)->isref = 1;
       }
   ;
    break;}
case 288:
#line 1716 "c51.y"
{
       seqPointNo++;
       if (inCritical) {
           werror(E_INVALID_CRITICAL);
           yyval.asts = NULL;
       } else {
           yyval.asts = newNode(RETURN,NULL,NULL);
       }
   ;
    break;}
case 289:
#line 1725 "c51.y"
{
       seqPointNo++;
       if (inCritical) {
           werror(E_INVALID_CRITICAL);
           yyval.asts = NULL;
       } else {
           yyval.asts = newNode(RETURN,NULL,yyvsp[-1].asts);
       }
   ;
    break;}
case 290:
#line 1737 "c51.y"
{ yyval.sym = newSymbol (yyvsp[0].yychar,NestLevel) ; ;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 543 "/usr/local/share/bison.simple"

  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YYLSP_NEEDED
  yylsp -= yylen;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;

#ifdef YYERROR_VERBOSE
      yyn = yypact[yystate];

      if (yyn > YYFLAG && yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
	  for (x = (yyn < 0 ? -yyn : 0);
	       x < (sizeof(yytname) / sizeof(char *)); x++)
	    if (yycheck[x + yyn] == x)
	      size += strlen(yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (yyn < 0 ? -yyn : 0);
		       x < (sizeof(yytname) / sizeof(char *)); x++)
		    if (yycheck[x + yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      yyerror(msg);
	      free(msg);
	    }
	  else
	    yyerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	yyerror("parse error");
    }

  goto yyerrlab1;
yyerrlab1:   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
#endif

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YYLSP_NEEDED
  yylsp--;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  yystate = yyn;
  goto yynewstate;

 yyacceptlab:
  /* YYACCEPT comes here.  */
  if (yyfree_stacks)
    {
      free (yyss);
      free (yyvs);
#ifdef YYLSP_NEEDED
      free (yyls);
#endif
    }
  return 0;

 yyabortlab:
  /* YYABORT comes here.  */
  if (yyfree_stacks)
    {
      free (yyss);
      free (yyvs);
#ifdef YYLSP_NEEDED
      free (yyls);
#endif
    }
  return 1;
}
#line 1739 "c51.y"

