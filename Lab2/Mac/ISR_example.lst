0000              1   ; vim:foldmethod=marker:foldlevel=0
0000              2   
0000              3   ; DOCS {{{
0000              4   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              5   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P1.7 using
0000              6   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              7   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to
0000              8   ; zero if the 'CLEAR' push button connected to P1.5 is pressed.
                 10   $LIST
0000             12   
0000             13   ;  N76E003 pinout:
0000             14   ;                               -------
0000             15   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             16   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             17   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             18   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             19   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             20   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             21   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             22   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             23   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             24   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             25   ;                               -------
0000             26   ; 1     0.5 - BUTTON 1
0000             27   ; 2     USED
0000             28   ; 3     USED
0000             29   ; 4     RESET BUTTON
0000             30   ; 5     3.0 - BUTTON 2
0000             31   ; 6     SPEAKER
0000             32   ; 7     GND
0000             33   ; 8     1.6 - BUTTON 4
0000             34   ; 9     VDD
0000             35   ; 10    1.5 - BUTTON 5
0000             36   ;
0000             37   ; 11    UNUSED
0000             38   ; 12    USED
0000             39   ; 13    USED
0000             40   ; 14    1.1 - BUTTON 3
0000             41   ; 15    USED
0000             42   ; 16    UNUSED
0000             43   ; 17    UNUSED
0000             44   ; 18    UNUSED
0000             45   ; 19    UNUSED
0000             46   ; 20    UNUSED
0000             47   
0000             48   ; Button mapping:
0000             49   ; Button 1 to 5, starting from  left to right
0000             50   ; BUTTON 1 - HOUR
0000             51   ; BUTTON 2 - MIN
0000             52   ; BUTTON 3 - SEC
0000             53   ; BUTTON 4 - TIME SET
0000             54   ; BUTTON 5 - ALARM
0000             55   
0000             56   ; CONFIG {{{
0000             57   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             58   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             59   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             60   TIMER2_RATE   EQU 500     ; 1000Hz, for a timer tick of 1ms
0000             61   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             62   
0000             63   UPDOWN        equ P1.6
0000             64   SOUND_OUT     equ P1.7
0000             65   BUTTON1       equ P0.5
0000             66   BUTTON2       equ P3.0
0000             67   BUTTON3       equ P1.1
0000             68   BUTTON4       equ P1.6
0000             69   BUTTON5       equ P1.5
0000             70   
0000             71   ; Reset vector
0000             72   org 0x0000
0000 02016A      73       ljmp main
0003             74   
0003             75   ; External interrupt 0 vector (not used in this code)
0003             76   org 0x0003
0003 32          77            reti
0004             78   
0004             79   ; Timer/Counter 0 overflow interrupt vector
000B             80   org 0x000B
000B 02010A      81            ljmp Timer0_ISR
000E             82   
000E             83   ; External interrupt 1 vector (not used in this code)
0013             84   org 0x0013
0013 32          85            reti
0014             86   
0014             87   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             88   org 0x001B
001B 32          89            reti
001C             90   
001C             91   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             92   org 0x0023
0023 32          93            reti
0024             94   
0024             95   ; Timer/Counter 2 overflow interrupt vector
002B             96   org 0x002B
002B 020134      97            ljmp Timer2_ISR
002E             98   
002E             99   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030            100   dseg at 0x30
0030            101   Count1ms:     ds 2 ; Used to determine when half second has passed
0032            102   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            103   min_counter:  ds 1
0034            104   hour_counter: ds 1
0035            105   day_state:    ds 1
0036            106   
0036            107   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0036            108   ; instructions with these variables.  This is how you define a 1-bit variable:
0000            109   bseg
0000            110   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001            111   
002E            112   cseg
002E            113   ; These 'equ' must match the hardware wiring
002E            114   LCD_RS equ P1.3
002E            115   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E            116   LCD_E  equ P1.4
002E            117   LCD_D4 equ P0.0
002E            118   LCD_D5 equ P0.1
002E            119   LCD_D6 equ P0.2
002E            120   LCD_D7 equ P0.3
002E            121   
                123   	$LIST
00E2            125   
00E2            126   ;                     1234567890123456    <- This helps determine the location of the counter
00E2 78783A78   127   Initial_Message:  db 'xx:xx:xx xx', 0
     783A7878
     20787800
00EE            128   ;                    '00:00:00 AM '
00EE 414D00     129   AM: db 'AM', 0
00F1 504D00     130   PM: db 'PM', 0
00F4            131   
00F4            132   ;---------------------------------;
00F4            133   ; Routine to initialize the ISR   ;
00F4            134   ; for timer 0                     ;
00F4            135   ;---------------------------------;
00F4            136   Timer0_Init:
00F4 438E08     137            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
00F7 E589       138            mov a, TMOD
00F9 54F0       139            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
00FB 4401       140            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
00FD F589       141            mov TMOD, a
00FF 758CF0     142            mov TH0, #high(TIMER0_RELOAD)
0102 758A2C     143            mov TL0, #low(TIMER0_RELOAD)
0105            144            ; Enable the timer and interrupts
0105 D2A9       145       setb ET0  ; Enable timer 0 interrupt
0107 D28C       146       setb TR0  ; Start timer 0
0109 22         147            ret
010A            148   
010A            149   ;---------------------------------;
010A            150   ; ISR for timer 0.  Set to execute;
010A            151   ; every 1/4096Hz to generate a    ;
010A            152   ; 2048 Hz wave at pin SOUND_OUT   ;
010A            153   ;---------------------------------;
010A            154   Timer0_ISR:
010A            155            ;clr TF0  ; According to the data sheet this is done for us already.
010A            156            ; Timer 0 doesn't have 16-bit auto-reload, so
010A C28C       157            clr TR0
010C 758CF0     158            mov TH0, #high(TIMER0_RELOAD)
010F 758A2C     159            mov TL0, #low(TIMER0_RELOAD)
0112 D28C       160            setb TR0
0114 B297       161            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
0116 32         162            reti
0117            163   
0117            164   ;---------------------------------;
0117            165   ; Routine to initialize the ISR   ;
0117            166   ; for timer 2                     ;
0117            167   ;---------------------------------;
0117            168   Timer2_Init:
0117 75C800     169            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
011A 75CD7E     170            mov TH2, #high(TIMER2_RELOAD)
011D 75CC50     171            mov TL2, #low(TIMER2_RELOAD)
0120            172            ; Set the reload value
0120 43C980     173            orl T2MOD, #0x80 ; Enable timer 2 autoreload
0123 75CB7E     174            mov RCMP2H, #high(TIMER2_RELOAD)
0126 75CA50     175            mov RCMP2L, #low(TIMER2_RELOAD)
0129            176            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0129 E4         177            clr a
012A F530       178            mov Count1ms+0, a
012C F531       179            mov Count1ms+1, a
012E            180            ; Enable the timer and interrupts
012E 439B80     181            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0131 D2CA       182       setb TR2  ; Enable timer 2
0133 22         183            ret
0134            184   
0134            185   ;---------------------------------;
0134            186   ; ISR for timer 2                 ;
0134            187   ;---------------------------------;
0134            188   Timer2_ISR:
0134 C2CF       189            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0136 B284       190            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0138            191   
0138            192            ; The two registers used in the ISR must be saved in the stack
0138 C0E0       193            push acc
013A C0D0       194            push psw
013C            195   
013C            196            ; Increment the 16-bit one mili second counter
013C 0530       197            inc Count1ms+0    ; Increment the low 8-bits first
013E E530       198            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0140 7002       199            jnz Inc_Done
0142 0531       200            inc Count1ms+1
0144            201   
0144            202   Inc_Done:
0144            203            ; Check if half second has passed
0144 E530       204            mov a, Count1ms+0
0146 B4F41C     205            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0149 E531       206            mov a, Count1ms+1
014B B40117     207            cjne a, #high(500), Timer2_ISR_done
014E            208   
014E            209            ; 500 milliseconds have passed.  Set a flag so the main program knows
014E D200       210            setb half_seconds_flag ; Let the main program know half second had passed
0150 B28C       211            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0152            212            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0152 E4         213            clr a
0153 F530       214            mov Count1ms+0, a
0155 F531       215            mov Count1ms+1, a
0157            216            ; Increment the BCD counter
0157 E532       217            mov a, BCD_counter
0159 309604     218            jnb UPDOWN, Timer2_ISR_decrement
015C 2401       219            add a, #0x01
015E 8002       220            sjmp Timer2_ISR_da
0160            221   Timer2_ISR_decrement:
0160 2499       222            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0162            223   Timer2_ISR_da:
0162 D4         224            da a ; Decimal adjust instruction.  Check datasheet for more details!
0163 F532       225            mov BCD_counter, a
0165            226   
0165            227   
0165            228   Timer2_ISR_done:
0165 D0D0       229            pop psw
0167 D0E0       230            pop acc
0169 32         231            reti
016A            232   ;}}}
016A            233   ;---------------------------------;
016A            234   ; Main program. Includes hardware ;
016A            235   ; initialization and 'forever'    ;
016A            236   ; loop.                           ;
016A            237   ;---------------------------------;
016A            238   ; MAIN LOOP + buttons {{{
016A            239   main:
016A            240            ; Initialization
016A 75817F     241       mov SP, #0x7F
016D 75B100     242       mov P0M1, #0x00
0170 75B200     243       mov P0M2, #0x00
0173 75B300     244       mov P1M1, #0x00
0176 75B400     245       mov P1M2, #0x00
0179 75AD00     246       mov P3M2, #0x00
017C 75AD00     247       mov P3M2, #0x00
017F            248   
017F 1200F4     249       lcall Timer0_Init
0182 120117     250       lcall Timer2_Init
0185 D2AF       251       setb EA   ; Enable Global interrupts
0187 120087     252       lcall LCD_4BIT
018A            253       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
018A C0E0       254            push acc
018C 7401       254            mov a, #1
018E 14         254            dec a
018F 1200C7     254            lcall ?Set_Cursor_1 ; Select column and row
0192 D0E0       254            pop acc
0194 C083       255            push dph
0196 C082       255            push dpl
0198 C0E0       255            push acc
019A 9000E2     255            mov dptr, #Initial_Message
019D 1200BA     255            lcall ?Send_Constant_String
01A0 D0E0       255            pop acc
01A2 D082       255            pop dpl
01A4 D083       255            pop dph
01A6 D200       256       setb half_seconds_flag
01A8 753200     257            mov BCD_counter, #0x00
01AB 753300     258       mov min_counter, #0x00
01AE 753400     259       mov hour_counter, #0x00
01B1 753500     260       mov day_state, #0 ; To configure AM/PM
01B4            261   
01B4            262            ; After initialization the program stays in this 'forever' loop
01B4            263   loop:
01B4 208511     264            jb BUTTON1, buttonjump2 ; if the 'CLEAR' button is not pressed skip
01B7 C002       265            push AR2
01B9 7A32       265            mov R2, #50
01BB 120038     265            lcall ?Wait_Milli_Seconds
01BE D002       265            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01C0 208505     266            jb BUTTON1, buttonjump2; if the 'CLEAR' button is not pressed skip
01C3 3085FD     267            jnb BUTTON1, $          ; Wait for button release.  The '$' means: jump to same instruction.
01C6 804E       268       sjmp clear
01C8            269   
01C8            270   buttonjump2:
01C8 20B011     271            jb BUTTON2, buttonjump3 ; if the 'CLEAR' button is not pressed skip
01CB C002       272            push AR2
01CD 7A32       272            mov R2, #50
01CF 120038     272            lcall ?Wait_Milli_Seconds
01D2 D002       272            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01D4 20B005     273            jb BUTTON2, buttonjump3; if the 'CLEAR' button is not pressed skip
01D7 30B0FD     274            jnb BUTTON2, $          ; Wait for button release.  The '$' means: jump to same instruction.
01DA 803A       275       sjmp clear
01DC            276   buttonjump3:
01DC 209111     277            jb BUTTON3, buttonjump4 ; if the 'CLEAR' button is not pressed skip
01DF C002       278            push AR2
01E1 7A32       278            mov R2, #50
01E3 120038     278            lcall ?Wait_Milli_Seconds
01E6 D002       278            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01E8 209105     279            jb BUTTON3, buttonjump4; if the 'CLEAR' button is not pressed skip
01EB 3091FD     280            jnb BUTTON3, $          ; Wait for button release.  The '$' means: jump to same instruction.
01EE 8026       281       sjmp clear
01F0            282   buttonjump4:
01F0 209611     283            jb BUTTON4, buttonjump5 ; if the 'CLEAR' button is not pressed skip
01F3 C002       284            push AR2
01F5 7A32       284            mov R2, #50
01F7 120038     284            lcall ?Wait_Milli_Seconds
01FA D002       284            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01FC 209605     285            jb BUTTON4, buttonjump5; if the 'CLEAR' button is not pressed skip
01FF 3096FD     286            jnb BUTTON4, $          ; Wait for button release.  The '$' means: jump to same instruction.
0202 8012       287       sjmp clear
0204            288   buttonjump5:
0204 20951C     289            jb BUTTON5, loop_a ; if the 'CLEAR' button is not pressed skip
0207 C002       290            push AR2
0209 7A32       290            mov R2, #50
020B 120038     290            lcall ?Wait_Milli_Seconds
020E D002       290            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0210 209510     291            jb BUTTON5, loop_a  ; if the 'CLEAR' button is not pressed skip
0213 3095FD     292            jnb BUTTON5, $          ; Wait for button release.  The '$' means: jump to same instruction.
0216            293   
0216            294   clear:
0216            295   
0216            296   
0216            297   
0216            298   
0216            299            ; A valid press of the 'CLEAR' button has been detected, reset the BCD counter.
0216            300            ; But first stop timer 2 and reset the milli-seconds counter, to resync everything.
0216 C2CA       301            clr TR2                 ; Stop timer 2
0218 E4         302            clr a
0219 F530       303            mov Count1ms+0, a
021B F531       304            mov Count1ms+1, a
021D            305            ; Now clear the BCD counter
021D F532       306            mov BCD_counter, a
021F D2CA       307            setb TR2                ; Start timer 2
0221 8003       308            sjmp loop_b             ; Display the new value
0223            309   
0223            310   ;}}}
0223            311   loop_a:
0223 30008E     312            jnb half_seconds_flag, loop
0226            313   ; LOOP B Display Timer {{{
0226            314   loop_b:
0226            315       ;Using this to print the time
0226 C200       316       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
0228            317   ;        Set_Cursor(1, 14)     ; the place in the LCD where we want the BCD counter value
0228            318   ;        Display_BCD(BCD_counter) ; This macro is also in 'LCD_4bit.inc'
0228            319   
0228 AC32       320       mov R4, BCD_counter
022A BC0605     321       CJNE R4, #6, secondskip
022D 753200     322       mov BCD_counter, #0x00
0230 0533       323       inc min_counter
0232            324   secondskip:
0232 C0E0       325            push acc
0234 7407       325            mov a, #7
0236 14         325            dec a
0237 1200C7     325            lcall ?Set_Cursor_1 ; Select column and row
023A D0E0       325            pop acc
023C C000       326            push ar0
023E A832       326            mov r0, BCD_counter
0240 1200CC     326            lcall ?Display_BCD
0243 D000       326            pop ar0
0245            327   
0245 AC33       328       mov R4, min_counter
0247 BC0205     329       CJNE R4, #2, minskip
024A 753300     330       mov min_counter, #0x00
024D 0534       331       inc hour_counter
024F            332   minskip:
024F C0E0       333            push acc
0251 7404       333            mov a, #4
0253 14         333            dec a
0254 1200C7     333            lcall ?Set_Cursor_1 ; Select column and row
0257 D0E0       333            pop acc
0259 C000       334            push ar0
025B A833       334            mov r0, min_counter
025D 1200CC     334            lcall ?Display_BCD
0260 D000       334            pop ar0
0262            335   
0262 AC34       336       mov R4, hour_counter
0264 BC0210     337       CJNE R4, #2, hourskip
0267 753400     338       mov hour_counter, #0x00
026A            339   ;Check states and run if else
026A AC35       340       mov R4, day_state
026C BC0005     341       cjne R4, #0, PMtoAM
026F            342   ;PMtoAM
026F 753501     343       mov day_state, #1
0272 8003       344       sjmp hourskip
0274            345   PMtoAM:
0274 753500     346       mov day_state, #0
0277            347   
0277            348   hourskip:
0277 C0E0       349            push acc
0279 7401       349            mov a, #1
027B 14         349            dec a
027C 1200C7     349            lcall ?Set_Cursor_1 ; Select column and row
027F D0E0       349            pop acc
0281 C000       350            push ar0
0283 A834       350            mov r0, hour_counter
0285 1200CC     350            lcall ?Display_BCD
0288 D000       350            pop ar0
028A            351   
028A            352   ;Check states and run alternate
028A AC35       353       mov R4, day_state
028C BC001F     354       CJNE R4, #0, timeAM
028F            355   timePM:
028F C0E0       356            push acc
0291 740A       356            mov a, #10
0293 14         356            dec a
0294 1200C7     356            lcall ?Set_Cursor_1 ; Select column and row
0297 D0E0       356            pop acc
0299 C083       357            push dph
029B C082       357            push dpl
029D C0E0       357            push acc
029F 9000F1     357            mov dptr, #PM
02A2 1200BA     357            lcall ?Send_Constant_String
02A5 D0E0       357            pop acc
02A7 D082       357            pop dpl
02A9 D083       357            pop dph
02AB 0201B4     358       ljmp loop
02AE            359   timeAM:
02AE C0E0       360            push acc
02B0 740A       360            mov a, #10
02B2 14         360            dec a
02B3 1200C7     360            lcall ?Set_Cursor_1 ; Select column and row
02B6 D0E0       360            pop acc
02B8            360   
02B8 C083       361            push dph
02BA C082       361            push dpl
02BC C0E0       361            push acc
02BE 9000EE     361            mov dptr, #AM
02C1 1200BA     361            lcall ?Send_Constant_String
02C4 D0E0       361            pop acc
02C6 D082       361            pop dpl
02C8 D083       361            pop dph
02CA 0201B4     362       ljmp loop
02CD            363   
02CD            364   ;}}}
02CD            365   END
