0000              1   ; vim:foldmethod=marker:foldlevel=0
0000              2   
0000              3   ; DOCS {{{
0000              4   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              5   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P1.7 using
0000              6   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              7   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to
0000              8   ; zero if the 'CLEAR' push button connected to P1.5 is pressed.
                 10   $LIST
0000             12   
0000             13   ;  N76E003 pinout:
0000             14   ;                               -------
0000             15   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             16   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             17   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             18   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             19   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             20   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             21   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             22   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             23   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             24   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             25   ;                               -------
0000             26   ; 1     0.5 - BUTTON 1
0000             27   ; 2     USED
0000             28   ; 3     USED
0000             29   ; 4     RESET BUTTON
0000             30   ; 5     3.0 - BUTTON 2
0000             31   ; 6     SPEAKER
0000             32   ; 7     GND
0000             33   ; 8     1.6 - BUTTON 4
0000             34   ; 9     VDD
0000             35   ; 10    1.5 - BUTTON 5
0000             36   ;
0000             37   ; 11    UNUSED
0000             38   ; 12    USED
0000             39   ; 13    USED
0000             40   ; 14    1.1 - BUTTON 3
0000             41   ; 15    USED
0000             42   ; 16    UNUSED
0000             43   ; 17    UNUSED
0000             44   ; 18    UNUSED
0000             45   ; 19    UNUSED
0000             46   ; 20    UNUSED
0000             47   
0000             48   ; Button mapping:
0000             49   ; Button 1 to 5, starting from  left to right
0000             50   ; BUTTON 1 - HOUR
0000             51   ; BUTTON 2 - MIN
0000             52   ; BUTTON 3 - SEC
0000             53   ; BUTTON 4 - TIME SET
0000             54   ; BUTTON 5 - ALARM
0000             55   ; }}}
0000             56   ; CONFIG {{{
0000             57   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             58   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             59   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             60   TIMER2_RATE   EQU 2000     ; 1000Hz, for a timer tick of 1ms
0000             61   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             62   
0000             63   UPDOWN        equ P1.6
0000             64   SOUND_OUT     equ P1.7
0000             65   BUTTON1       equ P0.5
0000             66   BUTTON2       equ P3.0
0000             67   BUTTON3       equ P1.1
0000             68   BUTTON4       equ P1.6
0000             69   BUTTON5       equ P1.5
0000             70   
0000             71   ; Reset vector
0000             72   org 0x0000
0000 020182      73       ljmp main
0003             74   
0003             75   ; External interrupt 0 vector (not used in this code)
0003             76   org 0x0003
0003 32          77            reti
0004             78   
0004             79   ; Timer/Counter 0 overflow interrupt vector
000B             80   org 0x000B
000B 020122      81            ljmp Timer0_ISR
000E             82   
000E             83   ; External interrupt 1 vector (not used in this code)
0013             84   org 0x0013
0013 32          85            reti
0014             86   
0014             87   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             88   org 0x001B
001B 32          89            reti
001C             90   
001C             91   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             92   org 0x0023
0023 32          93            reti
0024             94   
0024             95   ; Timer/Counter 2 overflow interrupt vector
002B             96   org 0x002B
002B 02014C      97            ljmp Timer2_ISR
002E             98   
002E             99   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030            100   dseg at 0x30
0030            101   Count1ms:           ds 2 ; Used to determine when half second has passed
0032            102   BCD_counter:        ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            103   min_counter:        ds 1
0034            104   hour_counter:       ds 1
0035            105   day_state:          ds 1
0036            106   timesetseconds:     ds 1
0037            107   timesetminutes:     ds 1
0038            108   timesethours:       ds 1
0039            109   timesetdaystate:    ds 1
003A            110   alarmseconds:       ds 1
003B            111   alarmminutes:       ds 1
003C            112   alarmhours:         ds 1
003D            113   alarmday_state:     ds 1
003E            114   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
003E            115   ; instructions with these variables.  This is how you define a 1-bit variable:
0000            116   bseg
0000            117   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001            118   
002E            119   cseg
002E            120   ; These 'equ' must match the hardware wiring
002E            121   LCD_RS equ P1.3
002E            122   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E            123   LCD_E  equ P1.4
002E            124   LCD_D4 equ P0.0
002E            125   LCD_D5 equ P0.1
002E            126   LCD_D6 equ P0.2
002E            127   LCD_D7 equ P0.3
002E            128   
                130   	$LIST
00E2            132   
00E2            133   ;                     1234567890123456    <- This helps determine the location of the counter
00E2 78783A78   134   Initial_Message:  db 'xx:xx:xx xx', 0
     783A7878
     20787800
00EE            135   ;                    '00:00:00 AM '
00EE 78783A78   136   Alarm_Message: db    'xx:xx:xx XX XXX', 0
     783A7878
     20585820
     58585800
00FE 414D00     137   AM: db 'AM', 0
0101 504D00     138   PM: db 'PM', 0
0104 4F4E2000   139   ON: db 'ON ', 0
0108 4F464600   140   OFF: db 'OFF', 0
010C            141   
010C            142   ;---------------------------------;
010C            143   ; Routine to initialize the ISR   ;
010C            144   ; for timer 0                     ;
010C            145   ;---------------------------------;
010C            146   Timer0_Init:
010C 438E08     147            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
010F E589       148            mov a, TMOD
0111 54F0       149            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
0113 4401       150            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
0115 F589       151            mov TMOD, a
0117 758CF0     152            mov TH0, #high(TIMER0_RELOAD)
011A 758A2C     153            mov TL0, #low(TIMER0_RELOAD)
011D            154            ; Enable the timer and interrupts
011D D2A9       155       setb ET0  ; Enable timer 0 interrupt
011F D28C       156       setb TR0  ; Start timer 0
0121 22         157            ret
0122            158   
0122            159   ;---------------------------------;
0122            160   ; ISR for timer 0.  Set to execute;
0122            161   ; every 1/4096Hz to generate a    ;
0122            162   ; 2048 Hz wave at pin SOUND_OUT   ;
0122            163   ;---------------------------------;
0122            164   Timer0_ISR:
0122            165            ;clr TF0  ; According to the data sheet this is done for us already.
0122            166            ; Timer 0 doesn't have 16-bit auto-reload, so
0122 C28C       167            clr TR0
0124 758CF0     168            mov TH0, #high(TIMER0_RELOAD)
0127 758A2C     169            mov TL0, #low(TIMER0_RELOAD)
012A D28C       170            setb TR0
012C B297       171            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
012E 32         172            reti
012F            173   
012F            174   ;---------------------------------;
012F            175   ; Routine to initialize the ISR   ;
012F            176   ; for timer 2                     ;
012F            177   ;---------------------------------;
012F            178   Timer2_Init:
012F 75C800     179            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0132 75CDDF     180            mov TH2, #high(TIMER2_RELOAD)
0135 75CC94     181            mov TL2, #low(TIMER2_RELOAD)
0138            182            ; Set the reload value
0138 43C980     183            orl T2MOD, #0x80 ; Enable timer 2 autoreload
013B 75CBDF     184            mov RCMP2H, #high(TIMER2_RELOAD)
013E 75CA94     185            mov RCMP2L, #low(TIMER2_RELOAD)
0141            186            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0141 E4         187            clr a
0142 F530       188            mov Count1ms+0, a
0144 F531       189            mov Count1ms+1, a
0146            190            ; Enable the timer and interrupts
0146 439B80     191            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0149 D2CA       192       setb TR2  ; Enable timer 2
014B 22         193            ret
014C            194   
014C            195   ;---------------------------------;
014C            196   ; ISR for timer 2                 ;
014C            197   ;---------------------------------;
014C            198   Timer2_ISR:
014C C2CF       199            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
014E B284       200            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0150            201   
0150            202            ; The two registers used in the ISR must be saved in the stack
0150 C0E0       203            push acc
0152 C0D0       204            push psw
0154            205   
0154            206            ; Increment the 16-bit one mili second counter
0154 0530       207            inc Count1ms+0    ; Increment the low 8-bits first
0156 E530       208            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0158 7002       209            jnz Inc_Done
015A 0531       210            inc Count1ms+1
015C            211   
015C            212   Inc_Done:
015C            213            ; Check if half second has passed
015C E530       214            mov a, Count1ms+0
015E B4F41C     215            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0161 E531       216            mov a, Count1ms+1
0163 B40117     217            cjne a, #high(500), Timer2_ISR_done
0166            218   
0166            219            ; 500 milliseconds have passed.  Set a flag so the main program knows
0166 D200       220            setb half_seconds_flag ; Let the main program know half second had passed
0168 B28C       221            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
016A            222            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
016A E4         223            clr a
016B F530       224            mov Count1ms+0, a
016D F531       225            mov Count1ms+1, a
016F            226            ; Increment the BCD counter
016F E532       227            mov a, BCD_counter
0171 309604     228            jnb UPDOWN, Timer2_ISR_decrement
0174 2401       229            add a, #0x01
0176 8002       230            sjmp Timer2_ISR_da
0178            231   Timer2_ISR_decrement:
0178 2499       232            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
017A            233   Timer2_ISR_da:
017A D4         234            da a ; Decimal adjust instruction.  Check datasheet for more details!
017B F532       235            mov BCD_counter, a
017D            236   
017D            237   
017D D0D0       238   Timer2_ISR_done: pop psw
017F D0E0       239            pop acc
0181 32         240            reti
0182            241   ;}}}
0182            242   ; MAIN + BUTTONS {{{
0182            243   ;---------------------------------;
0182            244   ; Main program. Includes hardware ;
0182            245   ; initialization and 'forever'    ;
0182            246   ; loop.                           ;
0182            247   ;---------------------------------;
0182            248   main:
0182            249            ; Initialization
0182 75817F     250       mov SP, #0x7F
0185 75B100     251       mov P0M1, #0x00
0188 75B200     252       mov P0M2, #0x00
018B 75B300     253       mov P1M1, #0x00
018E 75B400     254       mov P1M2, #0x00
0191 75AD00     255       mov P3M2, #0x00
0194 75AD00     256       mov P3M2, #0x00
0197            257   
0197 12010C     258       lcall Timer0_Init
019A 12012F     259       lcall Timer2_Init
019D D2AF       260       setb EA   ; Enable Global interrupts
019F 120087     261       lcall LCD_4BIT
01A2            262       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
01A2 C0E0       263            push acc
01A4 7401       263            mov a, #1
01A6 14         263            dec a
01A7 1200C7     263            lcall ?Set_Cursor_1 ; Select column and row
01AA D0E0       263            pop acc
01AC C083       264            push dph
01AE C082       264            push dpl
01B0 C0E0       264            push acc
01B2 9000E2     264            mov dptr, #Initial_Message
01B5 1200BA     264            lcall ?Send_Constant_String
01B8 D0E0       264            pop acc
01BA D082       264            pop dpl
01BC D083       264            pop dph
01BE C0E0       265            push acc
01C0 7401       265            mov a, #1
01C2 14         265            dec a
01C3 1200C5     265            lcall ?Set_Cursor_2 ; Select column and row
01C6 D0E0       265            pop acc
01C8            266       ;Send_Constant_String(#Alarm_Message)
01C8 D200       267       setb half_seconds_flag
01CA 753200     268            mov BCD_counter, #00
01CD 753300     269       mov min_counter, #00
01D0 753400     270       mov hour_counter, #00
01D3 753500     271       mov day_state, #0 ; To configure AM/PM
01D6 753600     272       mov timesetseconds, #00
01D9 753700     273       mov timesetminutes, #00
01DC 753800     274       mov timesethours, #0x00
01DF 753900     275       mov timesetdaystate, #0
01E2 753A02     276       mov alarmseconds, #0x02
01E5 753B02     277       mov alarmminutes, #0x02
01E8 753C02     278       mov alarmhours, #0x02
01EB            279   
01EB            280            ; After initialization the program stays in this 'forever' loop
01EB            281   loop:
01EB 208514     282            jb BUTTON1, buttonjump2 ; if the 'CLEAR' button is not pressed skip
01EE C002       283            push AR2
01F0 7A32       283            mov R2, #50
01F2 120038     283            lcall ?Wait_Milli_Seconds
01F5 D002       283            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01F7 208508     284            jb BUTTON1, buttonjump2; if the 'CLEAR' button is not pressed skip
01FA 3085FD     285            jnb BUTTON1, $          ; Wait for button release.  The '$' means: jump to same instruction.
01FD 053A       286       inc alarmseconds
01FF 02026A     287       ljmp loop_b
0202            288   
0202            289   buttonjump2:
0202 20B014     290            jb BUTTON2, buttonjump3 ; if the 'CLEAR' button is not pressed skip
0205 C002       291            push AR2
0207 7A32       291            mov R2, #50
0209 120038     291            lcall ?Wait_Milli_Seconds
020C D002       291            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
020E 20B008     292            jb BUTTON2, buttonjump3; if the 'CLEAR' button is not pressed skip
0211 30B0FD     293            jnb BUTTON2, $          ; Wait for button release.  The '$' means: jump to same instruction.
0214 053B       294       inc alarmminutes
0216 02026A     295       ljmp loop_b
0219            296   buttonjump3:
0219 209114     297            jb BUTTON3, buttonjump4 ; if the 'CLEAR' button is not pressed skip
021C C002       298            push AR2
021E 7A32       298            mov R2, #50
0220 120038     298            lcall ?Wait_Milli_Seconds
0223 D002       298            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0225 209108     299            jb BUTTON3, buttonjump4; if the 'CLEAR' button is not pressed skip
0228 3091FD     300            jnb BUTTON3, $          ; Wait for button release.  The '$' means: jump to same instruction.
022B 053C       301       inc alarmhours
022D 02026A     302       ljmp loop_b
0230            303   buttonjump4:
0230 209612     304            jb BUTTON4, buttonjump5 ; if the 'CLEAR' button is not pressed skip
0233 C002       305            push AR2
0235 7A32       305            mov R2, #50
0237 120038     305            lcall ?Wait_Milli_Seconds
023A D002       305            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
023C 209606     306            jb BUTTON4, buttonjump5; if the 'CLEAR' button is not pressed skip
023F 3096FD     307            jnb BUTTON4, $          ; Wait for button release.  The '$' means: jump to same instruction.
0242 0203BE     308       ljmp displaytimesetfunction
0245            309   buttonjump5:
0245 209522     310            jb BUTTON5, loop_b ; if the 'CLEAR' button is not pressed skip
0248 C002       311            push AR2
024A 7A32       311            mov R2, #50
024C 120038     311            lcall ?Wait_Milli_Seconds
024F D002       311            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0251 209516     312            jb BUTTON5, loop_b  ; if the 'CLEAR' button is not pressed skip
0254 3095FD     313            jnb BUTTON5, $          ; Wait for button release.  The '$' means: jump to same instruction.
0257 8000       314       sjmp clear
0259            315   
0259            316   clear:
0259            317            ; A valid press of the 'CLEAR' button has been detected, reset the BCD counter.
0259            318            ; But first stop timer 2 and reset the milli-seconds counter, to resync everything.
0259 C2CA       319            clr TR2                 ; Stop timer 2
025B E4         320            clr a
025C F530       321            mov Count1ms+0, a
025E F531       322            mov Count1ms+1, a
0260            323            ; Now clear the BCD counter
0260 F532       324            mov BCD_counter, a
0262 D2CA       325            setb TR2                ; Start timer 2
0264            326       ;lcall loop_b
0264 0201EB     327       ljmp loop
0267            328   
0267            329   ;}}}
0267            330   ; LOOP B Display Timer {{{
0267            331   loop_a:
0267 300081     332            jnb half_seconds_flag, loop
026A            333   loop_b:
026A            334       ;Using this to print the time
026A C200       335       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
026C            336   ;        Set_Cursor(1, 14)     ; the place in the LCD where we want the BCD counter value
026C            337   ;        Display_BCD(BCD_counter) ; This macro is also in 'LCD_4bit.inc'
026C            338   
026C AC32       339       mov R4, BCD_counter
026E BC010A     340       CJNE R4, #0x1, secondskip
0271 753200     341       mov BCD_counter, #00
0274            342       ;inc min_counter
0274 E533       343       mov a, min_counter
0276 2401       344       add A, #1
0278 D4         345       da a
0279 F533       346       mov min_counter, A
027B            347   secondskip:
027B C0E0       348            push acc
027D 7407       348            mov a, #7
027F 14         348            dec a
0280 1200C7     348            lcall ?Set_Cursor_1 ; Select column and row
0283 D0E0       348            pop acc
0285 C000       349            push ar0
0287 A832       349            mov r0, BCD_counter
0289 1200CC     349            lcall ?Display_BCD
028C D000       349            pop ar0
028E            350   
028E E533       351       mov a, min_counter
0290 B4010A     352       CJNE a, #0x1, minskip
0293 753300     353       mov min_counter, #00
0296            354       ;inc hour_counter;
0296 E534       355       mov a, hour_counter
0298 2401       356       add A, #1
029A D4         357       da a
029B F534       358       mov hour_counter, A
029D            359   minskip:
029D C0E0       360            push acc
029F 7404       360            mov a, #4
02A1 14         360            dec a
02A2 1200C7     360            lcall ?Set_Cursor_1 ; Select column and row
02A5 D0E0       360            pop acc
02A7 C000       361            push ar0
02A9 A833       361            mov r0, min_counter
02AB 1200CC     361            lcall ?Display_BCD
02AE D000       361            pop ar0
02B0            362   
02B0 AC34       363       mov R4, hour_counter
02B2 BC1310     364       CJNE R4, #0x13, hourskip
02B5 753401     365       mov hour_counter, #0x01
02B8            366   ;Check states and run if else
02B8 AC35       367       mov R4, day_state
02BA BC0005     368       cjne R4, #0, PMtoAM
02BD            369   ;PMtoAM
02BD 753501     370       mov day_state, #1
02C0 8003       371       sjmp hourskip
02C2            372   PMtoAM:
02C2 753500     373       mov day_state, #0
02C5            374   
02C5            375   hourskip:
02C5 C0E0       376            push acc
02C7 7401       376            mov a, #1
02C9 14         376            dec a
02CA 1200C7     376            lcall ?Set_Cursor_1 ; Select column and row
02CD D0E0       376            pop acc
02CF C000       377            push ar0
02D1 A834       377            mov r0, hour_counter
02D3 1200CC     377            lcall ?Display_BCD
02D6 D000       377            pop ar0
02D8            378   
02D8            379   ;Check states and run alternate
02D8 AC35       380       mov R4, day_state
02DA BC001E     381       CJNE R4, #0, timeAM
02DD            382   timePM:
02DD C0E0       383            push acc
02DF 740A       383            mov a, #10
02E1 14         383            dec a
02E2 1200C7     383            lcall ?Set_Cursor_1 ; Select column and row
02E5 D0E0       383            pop acc
02E7 C083       384            push dph
02E9 C082       384            push dpl
02EB C0E0       384            push acc
02ED 900101     384            mov dptr, #PM
02F0 1200BA     384            lcall ?Send_Constant_String
02F3 D0E0       384            pop acc
02F5 D082       384            pop dpl
02F7 D083       384            pop dph
02F9 801E       385       sjmp alarm
02FB            386   timeAM:
02FB C0E0       387            push acc
02FD 740A       387            mov a, #10
02FF 14         387            dec a
0300 1200C7     387            lcall ?Set_Cursor_1 ; Select column and row
0303 D0E0       387            pop acc
0305            387   
0305 C083       388            push dph
0307 C082       388            push dpl
0309 C0E0       388            push acc
030B 9000FE     388            mov dptr, #AM
030E 1200BA     388            lcall ?Send_Constant_String
0311 D0E0       388            pop acc
0313 D082       388            pop dpl
0315 D083       388            pop dph
0317 8000       389       sjmp alarm
0319            390   
0319            391   
0319            392   alarm:
0319 AC3A       393       mov R4, alarmseconds
031B BC0605     394       CJNE R4, #0x06, asecondskip
031E 753A00     395       mov alarmseconds, #000
0321 053B       396       inc alarmminutes
0323            397   asecondskip:
0323 C0E0       398            push acc
0325 7407       398            mov a, #7
0327 14         398            dec a
0328 1200C5     398            lcall ?Set_Cursor_2 ; Select column and row
032B D0E0       398            pop acc
032D C000       399            push ar0
032F A83A       399            mov r0, alarmseconds
0331 1200CC     399            lcall ?Display_BCD
0334 D000       399            pop ar0
0336            400   
0336 AC3B       401       mov R4, alarmminutes
0338 BC0605     402       CJNE R4, #0x06, aminskip
033B 753B00     403       mov alarmminutes, #000
033E 053C       404       inc alarmhours
0340            405   aminskip:
0340 C0E0       406            push acc
0342 7404       406            mov a, #4
0344 14         406            dec a
0345 1200C5     406            lcall ?Set_Cursor_2 ; Select column and row
0348 D0E0       406            pop acc
034A C000       407            push ar0
034C A83B       407            mov r0, alarmminutes
034E 1200CC     407            lcall ?Display_BCD
0351 D000       407            pop ar0
0353            408   
0353 AC3C       409       mov R4, alarmhours
0355 BC1210     410       CJNE R4, #0x12, ahourskip
0358 753C00     411       mov alarmhours, #000
035B            412   ;Check states and run if else
035B AC3D       413       mov R4, alarmday_state
035D BC0005     414       cjne R4, #0, aPMtoAM
0360            415   ;PMtoAM
0360 753D01     416       mov alarmday_state, #1
0363 8003       417       sjmp ahourskip
0365            418   aPMtoAM:
0365 753D00     419       mov alarmday_state, #0
0368            420   
0368            421   ahourskip:
0368 C0E0       422            push acc
036A 7401       422            mov a, #1
036C 14         422            dec a
036D 1200C5     422            lcall ?Set_Cursor_2 ; Select column and row
0370 D0E0       422            pop acc
0372 C000       423            push ar0
0374 A83C       423            mov r0, alarmhours
0376 1200CC     423            lcall ?Display_BCD
0379 D000       423            pop ar0
037B            424   
037B            425   ;Check states and run alternate
037B AC3D       426       mov R4, alarmday_state
037D BC001F     427       CJNE R4, #0, atimeAM
0380            428   atimePM:
0380 C0E0       429            push acc
0382 740A       429            mov a, #10
0384 14         429            dec a
0385 1200C5     429            lcall ?Set_Cursor_2 ; Select column and row
0388 D0E0       429            pop acc
038A            429   
038A C083       430            push dph
038C C082       430            push dpl
038E C0E0       430            push acc
0390 900101     430            mov dptr, #PM
0393 1200BA     430            lcall ?Send_Constant_String
0396 D0E0       430            pop acc
0398 D082       430            pop dpl
039A D083       430            pop dph
039C 0201EB     431       ljmp loop
039F            432   atimeAM:
039F C0E0       433            push acc
03A1 740A       433            mov a, #10
03A3 14         433            dec a
03A4 1200C5     433            lcall ?Set_Cursor_2 ; Select column and row
03A7 D0E0       433            pop acc
03A9            433   
03A9 C083       434            push dph
03AB C082       434            push dpl
03AD C0E0       434            push acc
03AF 9000FE     434            mov dptr, #AM
03B2 1200BA     434            lcall ?Send_Constant_String
03B5 D0E0       434            pop acc
03B7 D082       434            pop dpl
03B9 D083       434            pop dph
03BB 0201EB     435       ljmp loop
03BE            436   ;}}}
03BE            437   ; DISPLAY TIME FUNCTION {{{
03BE            438   
03BE            439   displaytimesetfunction:
03BE            440   
03BE            441   loop2:
03BE 208513     442            jb BUTTON1, sbuttonjump2; if the 'CLEAR' button is not pressed skip
03C1 C002       443            push AR2
03C3 7A32       443            mov R2, #50
03C5 120038     443            lcall ?Wait_Milli_Seconds
03C8 D002       443            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
03CA 208507     444            jb BUTTON1, sbuttonjump2; if the 'CLEAR' button is not pressed skip
03CD 3085FD     445            jnb BUTTON1, $          ; Wait for button release.  The '$' means: jump to same instruction.
03D0 0534       446       inc hour_counter
03D2 8044       447       sjmp displaytimefunction
03D4            448   
03D4            449   sbuttonjump2:
03D4 20B013     450            jb BUTTON2, sbuttonjump3; if the 'CLEAR' button is not pressed skip
03D7 C002       451            push AR2
03D9 7AFF       451            mov R2, #255
03DB 120038     451            lcall ?Wait_Milli_Seconds
03DE D002       451            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
03E0 20B007     452            jb BUTTON2, sbuttonjump3; if the 'CLEAR' button is not pressed skip
03E3 30B0FD     453            jnb BUTTON2, $          ; Wait for button release.  The '$' means: jump to same instruction.
03E6 0533       454       inc min_counter
03E8 802E       455       sjmp displaytimefunction
03EA            456   sbuttonjump3:
03EA 209113     457            jb BUTTON3, sbuttonjump4; if the 'CLEAR' button is not pressed skip
03ED C002       458            push AR2
03EF 7A32       458            mov R2, #50
03F1 120038     458            lcall ?Wait_Milli_Seconds
03F4 D002       458            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
03F6 209107     459            jb BUTTON3, sbuttonjump4; if the 'CLEAR' button is not pressed skip
03F9 3091FD     460            jnb BUTTON3, $          ; Wait for button release.  The '$' means: jump to same instruction.
03FC 0536       461       inc timesetseconds
03FE 8018       462       sjmp displaytimefunction
0400            463   sbuttonjump4:
0400 209615     464            jb BUTTON4, displaytimefunction; if the 'CLEAR' button is not pressed skip
0403 C002       465            push AR2
0405 7A32       465            mov R2, #50
0407 120038     465            lcall ?Wait_Milli_Seconds
040A D002       465            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
040C 209609     466            jb BUTTON4, displaytimefunction; if the 'CLEAR' button is not pressed skip
040F 3096FD     467            jnb BUTTON4, $          ; Wait for button release.  The '$' means: jump to same instruction.
0412 853632     468       mov BCD_counter, timesetseconds
0415 0201EB     469       ljmp loop
0418            470   
0418            471   displaytimefunction:
0418 AC36       472       mov R4, timesetseconds
041A BC0603     473       CJNE R4, #6, ssecondskip
041D 753600     474       mov timesetseconds, #000
0420            475   ssecondskip:
0420 C0E0       476            push acc
0422 7407       476            mov a, #7
0424 14         476            dec a
0425 1200C7     476            lcall ?Set_Cursor_1 ; Select column and row
0428 D0E0       476            pop acc
042A C000       477            push ar0
042C A836       477            mov r0, timesetseconds
042E 1200CC     477            lcall ?Display_BCD
0431 D000       477            pop ar0
0433            478   
0433 AC33       479       mov R4, min_counter
0435 BC0603     480       CJNE R4, #6, sminskip
0438 753300     481       mov min_counter, #000
043B            482   sminskip:
043B C0E0       483            push acc
043D 7404       483            mov a, #4
043F 14         483            dec a
0440 1200C7     483            lcall ?Set_Cursor_1 ; Select column and row
0443 D0E0       483            pop acc
0445 C000       484            push ar0
0447 A833       484            mov r0, min_counter
0449 1200CC     484            lcall ?Display_BCD
044C D000       484            pop ar0
044E            485   
044E AC34       486       mov R4, hour_counter
0450 BC0C10     487       CJNE R4, #12, shourskip
0453 753400     488       mov hour_counter, #000
0456            489   ;Check states and run if else
0456 AC35       490       mov R4, day_state
0458 BC0005     491       cjne R4, #0, sPMtoAM
045B            492   ;PMtoAM
045B 753501     493       mov day_state, #1
045E 8003       494       sjmp shourskip
0460            495   sPMtoAM:
0460 753500     496       mov day_state, #0
0463            497   
0463            498   shourskip:
0463 C0E0       499            push acc
0465 7401       499            mov a, #1
0467 14         499            dec a
0468 1200C7     499            lcall ?Set_Cursor_1 ; Select column and row
046B D0E0       499            pop acc
046D C000       500            push ar0
046F A834       500            mov r0, hour_counter
0471 1200CC     500            lcall ?Display_BCD
0474 D000       500            pop ar0
0476            501   
0476            502   ;Check states and run alternate
0476 AC35       503       mov R4, day_state
0478 BC001F     504       CJNE R4, #0, stimeAM
047B            505   stimePM:
047B C0E0       506            push acc
047D 740A       506            mov a, #10
047F 14         506            dec a
0480 1200C7     506            lcall ?Set_Cursor_1 ; Select column and row
0483 D0E0       506            pop acc
0485            506   
0485 C083       507            push dph
0487 C082       507            push dpl
0489 C0E0       507            push acc
048B 900101     507            mov dptr, #PM
048E 1200BA     507            lcall ?Send_Constant_String
0491 D0E0       507            pop acc
0493 D082       507            pop dpl
0495 D083       507            pop dph
0497 0203BE     508       ljmp loop2
049A            509   stimeAM:
049A C0E0       510            push acc
049C 740A       510            mov a, #10
049E 14         510            dec a
049F 1200C7     510            lcall ?Set_Cursor_1 ; Select column and row
04A2 D0E0       510            pop acc
04A4            510   
04A4 C083       511            push dph
04A6 C082       511            push dpl
04A8 C0E0       511            push acc
04AA 9000FE     511            mov dptr, #AM
04AD 1200BA     511            lcall ?Send_Constant_String
04B0 D0E0       511            pop acc
04B2 D082       511            pop dpl
04B4 D083       511            pop dph
04B6 0203BE     512       ljmp loop2
04B9            513   ;}}}
04B9            514   END
