0000              1   ; vim:foldmethod=marker:foldlevel=0
0000              2   
0000              3   ; DOCS {{{
0000              4   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              5   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P1.7 using
0000              6   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              7   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to
0000              8   ; zero if the 'CLEAR' push button connected to P1.5 is pressed.
                 10   $LIST
0000             12   
0000             13   ;  N76E003 pinout:
0000             14   ;                               -------
0000             15   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             16   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             17   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             18   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             19   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             20   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             21   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             22   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             23   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             24   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             25   ;                               -------
0000             26   ; 1     0.5 - BUTTON 1
0000             27   ; 2     USED
0000             28   ; 3     USED
0000             29   ; 4     RESET BUTTON
0000             30   ; 5     3.0 - BUTTON 2
0000             31   ; 6     SPEAKER
0000             32   ; 7     GND
0000             33   ; 8     1.6 - BUTTON 4
0000             34   ; 9     VDD
0000             35   ; 10    1.5 - BUTTON 5
0000             36   ;
0000             37   ; 11    UNUSED
0000             38   ; 12    USED
0000             39   ; 13    USED
0000             40   ; 14    1.1 - BUTTON 3
0000             41   ; 15    USED
0000             42   ; 16    UNUSED
0000             43   ; 17    UNUSED
0000             44   ; 18    UNUSED
0000             45   ; 19    UNUSED
0000             46   ; 20    UNUSED
0000             47   
0000             48   ; Button mapping:
0000             49   ; Button 1 to 5, starting from  left to right
0000             50   ; BUTTON 1 - HOUR
0000             51   ; BUTTON 2 - MIN
0000             52   ; BUTTON 3 - SEC
0000             53   ; BUTTON 4 - TIME SET
0000             54   ; BUTTON 5 - ALARM
0000             55   ; }}}
0000             56   ; CONFIG {{{
0000             57   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             58   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             59   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             60   TIMER2_RATE   EQU 2000     ; 1000Hz, for a timer tick of 1ms
0000             61   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             62   
0000             63   UPDOWN        equ P1.6
0000             64   SOUND_OUT     equ P1.7
0000             65   BUTTON1       equ P0.5
0000             66   BUTTON2       equ P3.0
0000             67   BUTTON3       equ P1.1
0000             68   BUTTON4       equ P1.6
0000             69   BUTTON5       equ P1.5
0000             70   
0000             71   ; Reset vector
0000             72   org 0x0000
0000 02017C      73       ljmp main
0003             74   
0003             75   ; External interrupt 0 vector (not used in this code)
0003             76   org 0x0003
0003 32          77            reti
0004             78   
0004             79   ; Timer/Counter 0 overflow interrupt vector
000B             80   org 0x000B
000B 02011E      81            ljmp Timer0_ISR
000E             82   
000E             83   ; External interrupt 1 vector (not used in this code)
0013             84   org 0x0013
0013 32          85            reti
0014             86   
0014             87   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             88   org 0x001B
001B 32          89            reti
001C             90   
001C             91   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             92   org 0x0023
0023 32          93            reti
0024             94   
0024             95   ; Timer/Counter 2 overflow interrupt vector
002B             96   org 0x002B
002B 020146      97            ljmp Timer2_ISR
002E             98   
002E             99   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030            100   dseg at 0x30
0030            101   Count1ms:           ds 2 ; Used to determine when half second has passed
0032            102   BCD_counter:        ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            103   min_counter:        ds 1
0034            104   hour_counter:       ds 1
0035            105   day_state:          ds 1
0036            106   timesetseconds:     ds 1
0037            107   timesetminutes:     ds 1
0038            108   timesethours:       ds 1
0039            109   timesetdaystate:    ds 1
003A            110   alarmseconds:       ds 1
003B            111   alarmminutes:       ds 1
003C            112   alarmhours:         ds 1
003D            113   alarmday_state:     ds 1
003E            114   alarm_state:        ds 1
003F            115   alarm_on:           ds 1
0040            116   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0040            117   ; instructions with these variables.  This is how you define a 1-bit variable:
0000            118   bseg
0000            119   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001            120   
002E            121   cseg
002E            122   ; These 'equ' must match the hardware wiring
002E            123   LCD_RS equ P1.3
002E            124   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E            125   LCD_E  equ P1.4
002E            126   LCD_D4 equ P0.0
002E            127   LCD_D5 equ P0.1
002E            128   LCD_D6 equ P0.2
002E            129   LCD_D7 equ P0.3
002E            130   
                132   	$LIST
00E2            134   
00E2            135   ;                     1234567890123456    <- This helps determine the location of the counter
00E2 78783A78   136   Initial_Message:  db 'xx:xx:xx xx', 0
     783A7878
     20787800
00EE            137   ;                    '00:00:00 AM '
00EE 78783A78   138   Alarm_Message: db    'xx:xx:xx XX', 0
     783A7878
     20585800
00FA 414D00     139   AM: db 'AM', 0
00FD 504D00     140   PM: db 'PM', 0
0100 4F4E2000   141   ON: db 'ON ', 0
0104 4F464600   142   OFF: db 'OFF', 0
0108            143   
0108            144   ;---------------------------------;
0108            145   ; Routine to initialize the ISR   ;
0108            146   ; for timer 0                     ;
0108            147   ;---------------------------------;
0108            148   Timer0_Init:
0108 438E08     149            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
010B E589       150            mov a, TMOD
010D 54F0       151            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
010F 4401       152            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
0111 F589       153            mov TMOD, a
0113 758CF0     154            mov TH0, #high(TIMER0_RELOAD)
0116 758A2C     155            mov TL0, #low(TIMER0_RELOAD)
0119            156            ; Enable the timer and interrupts
0119 D2A9       157       setb ET0  ; Enable timer 0 interrupt
011B D28C       158       setb TR0  ; Start timer 0
011D 22         159            ret
011E            160   
011E            161   ;---------------------------------;
011E            162   ; ISR for timer 0.  Set to execute;
011E            163   ; every 1/4096Hz to generate a    ;
011E            164   ; 2048 Hz wave at pin SOUND_OUT   ;
011E            165   ;---------------------------------;
011E            166   Timer0_ISR:
011E            167            ;clr TF0  ; According to the data sheet this is done for us already.
011E            168            ; Timer 0 doesn't have 16-bit auto-reload, so
011E C28C       169            clr TR0
0120 758CF0     170            mov TH0, #high(TIMER0_RELOAD)
0123 758A2C     171            mov TL0, #low(TIMER0_RELOAD)
0126 D28C       172            setb TR0
0128            173            ;cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
0128 32         174            reti
0129            175   
0129            176   ;---------------------------------;
0129            177   ; Routine to initialize the ISR   ;
0129            178   ; for timer 2                     ;
0129            179   ;---------------------------------;
0129            180   Timer2_Init:
0129 75C800     181            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
012C 75CDDF     182            mov TH2, #high(TIMER2_RELOAD)
012F 75CC94     183            mov TL2, #low(TIMER2_RELOAD)
0132            184            ; Set the reload value
0132 43C980     185            orl T2MOD, #0x80 ; Enable timer 2 autoreload
0135 75CBDF     186            mov RCMP2H, #high(TIMER2_RELOAD)
0138 75CA94     187            mov RCMP2L, #low(TIMER2_RELOAD)
013B            188            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
013B E4         189            clr a
013C F530       190            mov Count1ms+0, a
013E F531       191            mov Count1ms+1, a
0140            192            ; Enable the timer and interrupts
0140 439B80     193            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0143 D2CA       194       setb TR2  ; Enable timer 2
0145 22         195            ret
0146            196   
0146            197   ;---------------------------------;
0146            198   ; ISR for timer 2                 ;
0146            199   ;---------------------------------;
0146            200   Timer2_ISR:
0146 C2CF       201            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0148 B284       202            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
014A            203   
014A            204            ; The two registers used in the ISR must be saved in the stack
014A C0E0       205            push acc
014C C0D0       206            push psw
014E            207   
014E            208            ; Increment the 16-bit one mili second counter
014E 0530       209            inc Count1ms+0    ; Increment the low 8-bits first
0150 E530       210            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0152 7002       211            jnz Inc_Done
0154 0531       212            inc Count1ms+1
0156            213   
0156            214   Inc_Done:
0156            215            ; Check if half second has passed
0156 E530       216            mov a, Count1ms+0
0158 B4F41C     217            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
015B E531       218            mov a, Count1ms+1
015D B40117     219            cjne a, #high(500), Timer2_ISR_done
0160            220   
0160            221            ; 500 milliseconds have passed.  Set a flag so the main program knows
0160 D200       222            setb half_seconds_flag ; Let the main program know half second had passed
0162 B28C       223            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0164            224            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0164 E4         225            clr a
0165 F530       226            mov Count1ms+0, a
0167 F531       227            mov Count1ms+1, a
0169            228            ; Increment the BCD counter
0169 E532       229            mov a, BCD_counter
016B 309604     230            jnb UPDOWN, Timer2_ISR_decrement
016E 2401       231            add a, #0x01
0170 8002       232            sjmp Timer2_ISR_da
0172            233   Timer2_ISR_decrement:
0172 2499       234            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0174            235   Timer2_ISR_da:
0174 D4         236            da a ; Decimal adjust instruction.  Check datasheet for more details!
0175 F532       237            mov BCD_counter, a
0177            238   
0177            239   
0177 D0D0       240   Timer2_ISR_done: pop psw
0179 D0E0       241            pop acc
017B 32         242            reti
017C            243   ;}}}
017C            244   ; MAIN + BUTTONS {{{
017C            245   ;---------------------------------;
017C            246   ; Main program. Includes hardware ;
017C            247   ; initialization and 'forever'    ;
017C            248   ; loop.                           ;
017C            249   ;---------------------------------;
017C            250   main:
017C            251            ; Initialization
017C 75817F     252       mov SP, #0x7F
017F 75B100     253       mov P0M1, #0x00
0182 75B200     254       mov P0M2, #0x00
0185 75B300     255       mov P1M1, #0x00
0188 75B400     256       mov P1M2, #0x00
018B 75AD00     257       mov P3M2, #0x00
018E 75AD00     258       mov P3M2, #0x00
0191            259   
0191 120108     260       lcall Timer0_Init
0194 120129     261       lcall Timer2_Init
0197 D2AF       262       setb EA   ; Enable Global interrupts
0199 120087     263       lcall LCD_4BIT
019C            264       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
019C C0E0       265            push acc
019E 7401       265            mov a, #1
01A0 14         265            dec a
01A1 1200C7     265            lcall ?Set_Cursor_1 ; Select column and row
01A4 D0E0       265            pop acc
01A6 C083       266            push dph
01A8 C082       266            push dpl
01AA C0E0       266            push acc
01AC 9000E2     266            mov dptr, #Initial_Message
01AF 1200BA     266            lcall ?Send_Constant_String
01B2 D0E0       266            pop acc
01B4 D082       266            pop dpl
01B6 D083       266            pop dph
01B8 C0E0       267            push acc
01BA 7401       267            mov a, #1
01BC 14         267            dec a
01BD 1200C5     267            lcall ?Set_Cursor_2 ; Select column and row
01C0 D0E0       267            pop acc
01C2 C083       268            push dph
01C4 C082       268            push dpl
01C6 C0E0       268            push acc
01C8 9000EE     268            mov dptr, #Alarm_Message
01CB 1200BA     268            lcall ?Send_Constant_String
01CE D0E0       268            pop acc
01D0 D082       268            pop dpl
01D2 D083       268            pop dph
01D4 D200       269       setb half_seconds_flag
01D6 753200     270            mov BCD_counter, #00
01D9 753300     271       mov min_counter, #00
01DC 753400     272       mov hour_counter, #00
01DF 753500     273       mov day_state, #0 ; To configure AM/PM
01E2 753600     274       mov timesetseconds, #00
01E5 753700     275       mov timesetminutes, #00
01E8 753800     276       mov timesethours, #0x00
01EB 753900     277       mov timesetdaystate, #0
01EE 753A00     278       mov alarmseconds, #0x0
01F1 753B00     279       mov alarmminutes, #0x0
01F4 753C02     280       mov alarmhours, #0x02
01F7 753E00     281       mov alarm_state, #0x00
01FA 753F00     282       mov alarm_on, #0x0
01FD            283   
01FD            284            ; After initialization the program stays in this 'forever' loop
01FD            285   loop:
01FD 208519     286            jb BUTTON1, buttonjump2 ; if the 'CLEAR' button is not pressed skip
0200 C002       287            push AR2
0202 7A32       287            mov R2, #50
0204 120038     287            lcall ?Wait_Milli_Seconds
0207 D002       287            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0209 20850D     288            jb BUTTON1, buttonjump2; if the 'CLEAR' button is not pressed skip
020C 3085FD     289            jnb BUTTON1, $          ; Wait for button release.  The '$' means: jump to same instruction.
020F            290       ;inc alarmhours
020F E53C       291       mov a, alarmhours
0211 2401       292       add A, #1
0213 D4         293       da a
0214 F53C       294       mov alarmhours, A
0216 020292     295       ljmp loop_b
0219            296   
0219            297   buttonjump2:
0219 20B019     298            jb BUTTON2, buttonjump3 ; if the 'CLEAR' button is not pressed skip
021C C002       299            push AR2
021E 7AC8       299            mov R2, #200
0220 120038     299            lcall ?Wait_Milli_Seconds
0223 D002       299            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0225 20B00D     300            jb BUTTON2, buttonjump3; if the 'CLEAR' button is not pressed skip
0228 30B0FD     301            jnb BUTTON2, $          ; Wait for button release.  The '$' means: jump to same instruction.
022B            302       ;inc alarmminutes
022B E53B       303       mov a, alarmminutes
022D 2401       304       add A, #1
022F D4         305       da a
0230 F53B       306       mov alarmminutes, A
0232 020292     307       ljmp loop_b
0235            308   buttonjump3:
0235 209119     309            jb BUTTON3, buttonjump4 ; if the 'CLEAR' button is not pressed skip
0238 C002       310            push AR2
023A 7A32       310            mov R2, #50
023C 120038     310            lcall ?Wait_Milli_Seconds
023F D002       310            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0241 20910D     311            jb BUTTON3, buttonjump4; if the 'CLEAR' button is not pressed skip
0244 3091FD     312            jnb BUTTON3, $          ; Wait for button release.  The '$' means: jump to same instruction.
0247            313       ;inc alarmseconds
0247 E53A       314       mov a, alarmseconds
0249 2401       315       add A, #1
024B D4         316       da a
024C F53A       317       mov alarmseconds, A
024E 020292     318       ljmp loop_b
0251            319   buttonjump4:
0251 209612     320            jb BUTTON4, buttonjump5 ; if the 'CLEAR' button is not pressed skip
0254 C002       321            push AR2
0256 7A32       321            mov R2, #50
0258 120038     321            lcall ?Wait_Milli_Seconds
025B D002       321            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
025D 209606     322            jb BUTTON4, buttonjump5; if the 'CLEAR' button is not pressed skip
0260 3096FD     323            jnb BUTTON4, $          ; Wait for button release.  The '$' means: jump to same instruction.
0263 020445     324       ljmp displaytimesetfunction
0266            325   buttonjump5:
0266 209529     326            jb BUTTON5, loop_b ; if the 'CLEAR' button is not pressed skip
0269 C002       327            push AR2
026B 7A32       327            mov R2, #50
026D 120038     327            lcall ?Wait_Milli_Seconds
0270 D002       327            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0272 20951D     328            jb BUTTON5, loop_b  ; if the 'CLEAR' button is not pressed skip
0275 3095FD     329            jnb BUTTON5, $          ; Wait for button release.  The '$' means: jump to same instruction.
0278 02027B     330       ljmp alarmday_state_branch
027B            331   
027B            332   alarmday_state_branch:
027B A83E       333       mov R0, alarm_state
027D B80005     334       cjne r0, #0, alternate
0280 753E01     335       mov alarm_state, #1
0283 800D       336       sjmp loop_b
0285            337   
0285            338   alternate:
0285 753E00     339       mov alarm_state, #0
0288 8008       340       sjmp loop_b
028A            341   ;clear:
028A            342   ;        ; A valid press of the 'CLEAR' button has been detected, reset the BCD counter.
028A            343   ;        ; But first stop timer 2 and reset the milli-seconds counter, to resync everything.
028A            344   ;        clr TR2                 ; Stop timer 2
028A            345   ;        clr a
028A            346   ;        mov Count1ms+0, a
028A            347   ;        mov Count1ms+1, a
028A            348   ;        ; Now clear the BCD counter
028A            349   ;        mov BCD_counter, a
028A            350   ;        setb TR2                ; Start timer 2
028A            351   ;   ;lcall loop_b
028A            352   ;  ljmp loop
028A            353   
028A            354   ;}}}
028A            355   ; LOOP B Display Timer {{
028A            356   loop_a:
028A 300002     357            jnb half_seconds_flag, int_loop
028D 8003       358       sjmp loop_b
028F            359   int_loop:
028F 0201FD     360       ljmp loop
0292            361   loop_b:
0292            362       ;Using this to print the time
0292 C200       363       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
0294            364   ;        Set_Cursor(1, 14)     ; the place in the LCD where we want the BCD counter value
0294            365   ;        Display_BCD(BCD_counter) ; This macro is also in 'LCD_4bit.inc'
0294            366   
0294 AC32       367       mov R4, BCD_counter
0296 BC600A     368       CJNE R4, #0x60, secondskip
0299 753200     369       mov BCD_counter, #00
029C            370       ;inc min_counter
029C E533       371       mov a, min_counter
029E 2401       372       add A, #1
02A0 D4         373       da a
02A1 F533       374       mov min_counter, A
02A3            375   secondskip:
02A3 C0E0       376            push acc
02A5 7407       376            mov a, #7
02A7 14         376            dec a
02A8 1200C7     376            lcall ?Set_Cursor_1 ; Select column and row
02AB D0E0       376            pop acc
02AD C000       377            push ar0
02AF A832       377            mov r0, BCD_counter
02B1 1200CC     377            lcall ?Display_BCD
02B4 D000       377            pop ar0
02B6            378   
02B6 E533       379       mov a, min_counter
02B8 B4600A     380       CJNE a, #0x60, minskip
02BB 753300     381       mov min_counter, #00
02BE            382       ;inc hour_counter;
02BE E534       383       mov a, hour_counter
02C0 2401       384       add A, #1
02C2 D4         385       da a
02C3 F534       386       mov hour_counter, A
02C5            387   minskip:
02C5 C0E0       388            push acc
02C7 7404       388            mov a, #4
02C9 14         388            dec a
02CA 1200C7     388            lcall ?Set_Cursor_1 ; Select column and row
02CD D0E0       388            pop acc
02CF C000       389            push ar0
02D1 A833       389            mov r0, min_counter
02D3 1200CC     389            lcall ?Display_BCD
02D6 D000       389            pop ar0
02D8            390   
02D8 AC34       391       mov R4, hour_counter
02DA BC1310     392       CJNE R4, #0x13, hourskip
02DD 753401     393       mov hour_counter, #0x01
02E0            394   ;Check states and run if else
02E0 AC35       395       mov R4, day_state
02E2 BC0005     396       cjne R4, #0, PMtoAM
02E5            397   ;PMtoAM
02E5 753501     398       mov day_state, #1
02E8 8003       399       sjmp hourskip
02EA            400   PMtoAM:
02EA 753500     401       mov day_state, #0
02ED            402   
02ED            403   hourskip:
02ED C0E0       404            push acc
02EF 7401       404            mov a, #1
02F1 14         404            dec a
02F2 1200C7     404            lcall ?Set_Cursor_1 ; Select column and row
02F5 D0E0       404            pop acc
02F7 C000       405            push ar0
02F9 A834       405            mov r0, hour_counter
02FB 1200CC     405            lcall ?Display_BCD
02FE D000       405            pop ar0
0300            406   
0300            407   ;Check states and run alternate
0300 AC35       408       mov R4, day_state
0302 BC001E     409       CJNE R4, #0, timeAM
0305            410   timePM:
0305 C0E0       411            push acc
0307 740A       411            mov a, #10
0309 14         411            dec a
030A 1200C7     411            lcall ?Set_Cursor_1 ; Select column and row
030D D0E0       411            pop acc
030F C083       412            push dph
0311 C082       412            push dpl
0313 C0E0       412            push acc
0315 9000FD     412            mov dptr, #PM
0318 1200BA     412            lcall ?Send_Constant_String
031B D0E0       412            pop acc
031D D082       412            pop dpl
031F D083       412            pop dph
0321            412   
0321 801E       413       sjmp alarm
0323            414   timeAM:
0323 C0E0       415            push acc
0325 740A       415            mov a, #10
0327 14         415            dec a
0328 1200C7     415            lcall ?Set_Cursor_1 ; Select column and row
032B D0E0       415            pop acc
032D            415   
032D C083       416            push dph
032F C082       416            push dpl
0331 C0E0       416            push acc
0333 9000FA     416            mov dptr, #AM
0336 1200BA     416            lcall ?Send_Constant_String
0339 D0E0       416            pop acc
033B D082       416            pop dpl
033D D083       416            pop dph
033F 8000       417       sjmp alarm
0341            418   
0341            419   
0341            420   alarm:
0341 AC3A       421       mov R4, alarmseconds
0343 BC0605     422       CJNE R4, #0x06, asecondskip
0346 753A00     423       mov alarmseconds, #000
0349 053B       424       inc alarmminutes
034B            425   asecondskip:
034B C0E0       426            push acc
034D 7407       426            mov a, #7
034F 14         426            dec a
0350 1200C5     426            lcall ?Set_Cursor_2 ; Select column and row
0353 D0E0       426            pop acc
0355 C000       427            push ar0
0357 A83A       427            mov r0, alarmseconds
0359 1200CC     427            lcall ?Display_BCD
035C D000       427            pop ar0
035E            428   
035E AC3B       429       mov R4, alarmminutes
0360 BC0605     430       CJNE R4, #0x06, aminskip
0363 753B00     431       mov alarmminutes, #000
0366 053C       432       inc alarmhours
0368            433   aminskip:
0368 C0E0       434            push acc
036A 7404       434            mov a, #4
036C 14         434            dec a
036D 1200C5     434            lcall ?Set_Cursor_2 ; Select column and row
0370 D0E0       434            pop acc
0372 C000       435            push ar0
0374 A83B       435            mov r0, alarmminutes
0376 1200CC     435            lcall ?Display_BCD
0379 D000       435            pop ar0
037B            436   
037B AC3C       437       mov R4, alarmhours
037D BC1210     438       CJNE R4, #0x12, ahourskip
0380 753C00     439       mov alarmhours, #000
0383            440   ;Check states and run if else
0383 AC3D       441       mov R4, alarmday_state
0385 BC0005     442       cjne R4, #0, aPMtoAM
0388            443   ;PMtoAM
0388 753D01     444       mov alarmday_state, #1
038B 8003       445       sjmp ahourskip
038D            446   aPMtoAM:
038D 753D00     447       mov alarmday_state, #0
0390            448   
0390            449   ahourskip:
0390 C0E0       450            push acc
0392 7401       450            mov a, #1
0394 14         450            dec a
0395 1200C5     450            lcall ?Set_Cursor_2 ; Select column and row
0398 D0E0       450            pop acc
039A C000       451            push ar0
039C A83C       451            mov r0, alarmhours
039E 1200CC     451            lcall ?Display_BCD
03A1 D000       451            pop ar0
03A3            452   
03A3            453   ;Check states and run alternate
03A3 AC3D       454       mov R4, alarmday_state
03A5 BC001E     455       CJNE R4, #0, atimeAM
03A8            456   atimePM:
03A8 C0E0       457            push acc
03AA 740A       457            mov a, #10
03AC 14         457            dec a
03AD 1200C5     457            lcall ?Set_Cursor_2 ; Select column and row
03B0 D0E0       457            pop acc
03B2            457   
03B2 C083       458            push dph
03B4 C082       458            push dpl
03B6 C0E0       458            push acc
03B8 9000FD     458            mov dptr, #PM
03BB 1200BA     458            lcall ?Send_Constant_String
03BE D0E0       458            pop acc
03C0 D082       458            pop dpl
03C2 D083       458            pop dph
03C4 801C       459       sjmp alarm_symbol
03C6            460   atimeAM:
03C6 C0E0       461            push acc
03C8 740A       461            mov a, #10
03CA 14         461            dec a
03CB 1200C5     461            lcall ?Set_Cursor_2 ; Select column and row
03CE D0E0       461            pop acc
03D0            461   
03D0 C083       462            push dph
03D2 C082       462            push dpl
03D4 C0E0       462            push acc
03D6 9000FA     462            mov dptr, #AM
03D9 1200BA     462            lcall ?Send_Constant_String
03DC D0E0       462            pop acc
03DE D082       462            pop dpl
03E0 D083       462            pop dph
03E2            463   
03E2            464   alarm_symbol:
03E2 C0E0       465            push acc
03E4 740D       465            mov a, #13
03E6 14         465            dec a
03E7 1200C5     465            lcall ?Set_Cursor_2 ; Select column and row
03EA D0E0       465            pop acc
03EC            465   
03EC A83E       466       mov R0, alarm_state
03EE B80018     467       cjne R0, #0x00, skip_this
03F1 C083       468            push dph
03F3 C082       468            push dpl
03F5 C0E0       468            push acc
03F7 900104     468            mov dptr, #OFF
03FA 1200BA     468            lcall ?Send_Constant_String
03FD D0E0       468            pop acc
03FF D082       468            pop dpl
0401 D083       468            pop dph
0403 753F00     469       mov alarm_on, #0
0406 0201FD     470       ljmp loop
0409            471   skip_this:
0409 C083       472            push dph
040B C082       472            push dpl
040D C0E0       472            push acc
040F 900100     472            mov dptr, #ON
0412 1200BA     472            lcall ?Send_Constant_String
0415 D0E0       472            pop acc
0417 D082       472            pop dpl
0419 D083       472            pop dph
041B 02041E     473       ljmp alarm_sound
041E            474   
041E            475   alarm_sound:
041E A83A       476       mov r0, alarmseconds
0420 A93B       477       mov r1, alarmminutes
0422 AA3C       478       mov r2, alarmhours
0424 AB34       479       mov r3, hour_counter
0426 AC33       480       mov r4, min_counter
0428 AD32       481       mov r5, BCD_counter
042A AE3D       482       mov r6, alarmday_state
042C AF35       483       mov r7, day_state
042E            484   
042E EA         485       mov a, r2
042F 9B         486       subb a, r3
0430 B4000F     487       cjne a, #0, noalarm
0433 E9         488       mov a, r1
0434 9C         489       subb a, r4
0435 B4000A     490       cjne a, #0, noalarm
0438 E8         491       mov a, r0
0439 9D         492       subb a, r5
043A B40005     493       cjne a, #0, noalarm
043D 753F01     494       mov alarm_on, #1
0440            495   
0440 B297       496       cpl sound_out
0442            497   
0442            498   noalarm:
0442 0201FD     499       ljmp loop
0445            500   ;}}}
0445            501   ; DISPLAY TIME FUNCTION {{{
0445            502   
0445            503   displaytimesetfunction:
0445            504   
0445            505   loop2:
0445 208513     506            jb BUTTON1, sbuttonjump2; if the 'CLEAR' button is not pressed skip
0448 C002       507            push AR2
044A 7A32       507            mov R2, #50
044C 120038     507            lcall ?Wait_Milli_Seconds
044F D002       507            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0451 208507     508            jb BUTTON1, sbuttonjump2; if the 'CLEAR' button is not pressed skip
0454 3085FD     509            jnb BUTTON1, $          ; Wait for button release.  The '$' means: jump to same instruction.
0457 0534       510       inc hour_counter
0459 8044       511       sjmp displaytimefunction
045B            512   
045B            513   sbuttonjump2:
045B 20B013     514            jb BUTTON2, sbuttonjump3; if the 'CLEAR' button is not pressed skip
045E C002       515            push AR2
0460 7AFF       515            mov R2, #255
0462 120038     515            lcall ?Wait_Milli_Seconds
0465 D002       515            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0467 20B007     516            jb BUTTON2, sbuttonjump3; if the 'CLEAR' button is not pressed skip
046A 30B0FD     517            jnb BUTTON2, $          ; Wait for button release.  The '$' means: jump to same instruction.
046D 0533       518       inc min_counter
046F 802E       519       sjmp displaytimefunction
0471            520   sbuttonjump3:
0471 209113     521            jb BUTTON3, sbuttonjump4; if the 'CLEAR' button is not pressed skip
0474 C002       522            push AR2
0476 7A32       522            mov R2, #50
0478 120038     522            lcall ?Wait_Milli_Seconds
047B D002       522            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
047D 209107     523            jb BUTTON3, sbuttonjump4; if the 'CLEAR' button is not pressed skip
0480 3091FD     524            jnb BUTTON3, $          ; Wait for button release.  The '$' means: jump to same instruction.
0483 0536       525       inc timesetseconds
0485 8018       526       sjmp displaytimefunction
0487            527   sbuttonjump4:
0487 209615     528            jb BUTTON4, displaytimefunction; if the 'CLEAR' button is not pressed skip
048A C002       529            push AR2
048C 7A32       529            mov R2, #50
048E 120038     529            lcall ?Wait_Milli_Seconds
0491 D002       529            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0493 209609     530            jb BUTTON4, displaytimefunction; if the 'CLEAR' button is not pressed skip
0496 3096FD     531            jnb BUTTON4, $          ; Wait for button release.  The '$' means: jump to same instruction.
0499 853632     532       mov BCD_counter, timesetseconds
049C 0201FD     533       ljmp loop
049F            534   
049F            535   displaytimefunction:
049F AC36       536       mov R4, timesetseconds
04A1 BC6003     537       CJNE R4, #0x60, ssecondskip
04A4 753600     538       mov timesetseconds, #000
04A7            539   ssecondskip:
04A7 C0E0       540            push acc
04A9 7407       540            mov a, #7
04AB 14         540            dec a
04AC 1200C7     540            lcall ?Set_Cursor_1 ; Select column and row
04AF D0E0       540            pop acc
04B1 C000       541            push ar0
04B3 A836       541            mov r0, timesetseconds
04B5 1200CC     541            lcall ?Display_BCD
04B8 D000       541            pop ar0
04BA            542   
04BA AC33       543       mov R4, min_counter
04BC BC6003     544       CJNE R4, #0x60, sminskip
04BF 753300     545       mov min_counter, #000
04C2            546   sminskip:
04C2 C0E0       547            push acc
04C4 7404       547            mov a, #4
04C6 14         547            dec a
04C7 1200C7     547            lcall ?Set_Cursor_1 ; Select column and row
04CA D0E0       547            pop acc
04CC C000       548            push ar0
04CE A833       548            mov r0, min_counter
04D0 1200CC     548            lcall ?Display_BCD
04D3 D000       548            pop ar0
04D5            549   
04D5 AC34       550       mov R4, hour_counter
04D7 BC0C10     551       CJNE R4, #12, shourskip
04DA 753401     552       mov hour_counter, #01
04DD            553   ;Check states and run if else
04DD AC35       554       mov R4, day_state
04DF BC0005     555       cjne R4, #0, sPMtoAM
04E2            556   ;PMtoAM
04E2 753501     557       mov day_state, #1
04E5 8003       558       sjmp shourskip
04E7            559   sPMtoAM:
04E7 753500     560       mov day_state, #0
04EA            561   
04EA            562   shourskip:
04EA C0E0       563            push acc
04EC 7401       563            mov a, #1
04EE 14         563            dec a
04EF 1200C7     563            lcall ?Set_Cursor_1 ; Select column and row
04F2 D0E0       563            pop acc
04F4 C000       564            push ar0
04F6 A834       564            mov r0, hour_counter
04F8 1200CC     564            lcall ?Display_BCD
04FB D000       564            pop ar0
04FD            565   
04FD            566   ;Check states and run alternate
04FD AC35       567       mov R4, day_state
04FF BC001F     568       CJNE R4, #0, stimeAM
0502            569   stimePM:
0502 C0E0       570            push acc
0504 740A       570            mov a, #10
0506 14         570            dec a
0507 1200C7     570            lcall ?Set_Cursor_1 ; Select column and row
050A D0E0       570            pop acc
050C            570   
050C C083       571            push dph
050E C082       571            push dpl
0510 C0E0       571            push acc
0512 9000FD     571            mov dptr, #PM
0515 1200BA     571            lcall ?Send_Constant_String
0518 D0E0       571            pop acc
051A D082       571            pop dpl
051C D083       571            pop dph
051E 020445     572       ljmp loop2
0521            573   stimeAM:
0521 C0E0       574            push acc
0523 740A       574            mov a, #10
0525 14         574            dec a
0526 1200C7     574            lcall ?Set_Cursor_1 ; Select column and row
0529 D0E0       574            pop acc
052B            574   
052B C083       575            push dph
052D C082       575            push dpl
052F C0E0       575            push acc
0531 9000FA     575            mov dptr, #AM
0534 1200BA     575            lcall ?Send_Constant_String
0537 D0E0       575            pop acc
0539 D082       575            pop dpl
053B D083       575            pop dph
053D 020445     576       ljmp loop2
0540            577   ;}}}
0540            578   END
