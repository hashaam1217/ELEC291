0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P1.7 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to
0000              5   ; zero if the 'CLEAR' push button connected to P1.5 is pressed.
                  7   $LIST
0000              9   
0000             10   ;  N76E003 pinout:
0000             11   ;                               -------
0000             12   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             13   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             14   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             15   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             16   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             17   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             18   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             19   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             20   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             21   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             22   ;                               -------
0000             23   ; 1     UNUSED
0000             24   ; 2     USED
0000             25   ; 3     USED
0000             26   ; 4     RESET BUTTON
0000             27   ; 5     UNUSED
0000             28   ; 6     UNUSED
0000             29   ; 7     GND
0000             30   ; 8     UNUSED
0000             31   ; 9     VDD
0000             32   ; 10    UNUSED
0000             33   ;
0000             34   ; 11    UNUSED
0000             35   ; 12    USED
0000             36   ; 13    USED
0000             37   ; 14    USED
0000             38   ; 15    USED
0000             39   ; 16    UNUSED
0000             40   ; 17    UNUSED
0000             41   ; 18    UNUSED
0000             42   ; 19    UNUSED
0000             43   ; 20    UNUSED
0000             44   
0000             45   
0000             46   
0000             47   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             48   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             49   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             50   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             51   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             52   
0000             53   CLEAR_BUTTON  equ P1.5
0000             54   UPDOWN        equ P1.6
0000             55   SOUND_OUT     equ P1.7
0000             56   
0000             57   ; Reset vector
0000             58   org 0x0000
0000 020164      59       ljmp main
0003             60   
0003             61   ; External interrupt 0 vector (not used in this code)
0003             62   org 0x0003
0003 32          63            reti
0004             64   
0004             65   ; Timer/Counter 0 overflow interrupt vector
000B             66   org 0x000B
000B 020104      67            ljmp Timer0_ISR
000E             68   
000E             69   ; External interrupt 1 vector (not used in this code)
0013             70   org 0x0013
0013 32          71            reti
0014             72   
0014             73   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             74   org 0x001B
001B 32          75            reti
001C             76   
001C             77   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             78   org 0x0023
0023 32          79            reti
0024             80   
0024             81   ; Timer/Counter 2 overflow interrupt vector
002B             82   org 0x002B
002B 02012E      83            ljmp Timer2_ISR
002E             84   
002E             85   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             86   dseg at 0x30
0030             87   Count1ms:     ds 2 ; Used to determine when half second has passed
0032             88   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033             89   
0033             90   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0033             91   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             92   bseg
0000             93   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001             94   
002E             95   cseg
002E             96   ; These 'equ' must match the hardware wiring
002E             97   LCD_RS equ P1.3
002E             98   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E             99   LCD_E  equ P1.4
002E            100   LCD_D4 equ P0.0
002E            101   LCD_D5 equ P0.1
002E            102   LCD_D6 equ P0.2
002E            103   LCD_D7 equ P0.3
002E            104   
                106   	$LIST
00E2            108   
00E2            109   ;                     1234567890123456    <- This helps determine the location of the counter
00E2 78783A78   110   Initial_Message:  db 'xx:xx:xx xx', 0
     783A7878
     20787800
00EE            111   ;                    '00:00:00 AM '
00EE            112   
00EE            113   ;---------------------------------;
00EE            114   ; Routine to initialize the ISR   ;
00EE            115   ; for timer 0                     ;
00EE            116   ;---------------------------------;
00EE            117   Timer0_Init:
00EE 438E08     118            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
00F1 E589       119            mov a, TMOD
00F3 54F0       120            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
00F5 4401       121            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
00F7 F589       122            mov TMOD, a
00F9 758CF0     123            mov TH0, #high(TIMER0_RELOAD)
00FC 758A2C     124            mov TL0, #low(TIMER0_RELOAD)
00FF            125            ; Enable the timer and interrupts
00FF D2A9       126       setb ET0  ; Enable timer 0 interrupt
0101 D28C       127       setb TR0  ; Start timer 0
0103 22         128            ret
0104            129   
0104            130   ;---------------------------------;
0104            131   ; ISR for timer 0.  Set to execute;
0104            132   ; every 1/4096Hz to generate a    ;
0104            133   ; 2048 Hz wave at pin SOUND_OUT   ;
0104            134   ;---------------------------------;
0104            135   Timer0_ISR:
0104            136            ;clr TF0  ; According to the data sheet this is done for us already.
0104            137            ; Timer 0 doesn't have 16-bit auto-reload, so
0104 C28C       138            clr TR0
0106 758CF0     139            mov TH0, #high(TIMER0_RELOAD)
0109 758A2C     140            mov TL0, #low(TIMER0_RELOAD)
010C D28C       141            setb TR0
010E B297       142            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
0110 32         143            reti
0111            144   
0111            145   ;---------------------------------;
0111            146   ; Routine to initialize the ISR   ;
0111            147   ; for timer 2                     ;
0111            148   ;---------------------------------;
0111            149   Timer2_Init:
0111 75C800     150            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0114 75CDBF     151            mov TH2, #high(TIMER2_RELOAD)
0117 75CC28     152            mov TL2, #low(TIMER2_RELOAD)
011A            153            ; Set the reload value
011A 43C980     154            orl T2MOD, #0x80 ; Enable timer 2 autoreload
011D 75CBBF     155            mov RCMP2H, #high(TIMER2_RELOAD)
0120 75CA28     156            mov RCMP2L, #low(TIMER2_RELOAD)
0123            157            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0123 E4         158            clr a
0124 F530       159            mov Count1ms+0, a
0126 F531       160            mov Count1ms+1, a
0128            161            ; Enable the timer and interrupts
0128 439B80     162            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
012B D2CA       163       setb TR2  ; Enable timer 2
012D 22         164            ret
012E            165   
012E            166   ;---------------------------------;
012E            167   ; ISR for timer 2                 ;
012E            168   ;---------------------------------;
012E            169   Timer2_ISR:
012E C2CF       170            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0130 B284       171            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0132            172   
0132            173            ; The two registers used in the ISR must be saved in the stack
0132 C0E0       174            push acc
0134 C0D0       175            push psw
0136            176   
0136            177            ; Increment the 16-bit one mili second counter
0136 0530       178            inc Count1ms+0    ; Increment the low 8-bits first
0138 E530       179            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
013A 7002       180            jnz Inc_Done
013C 0531       181            inc Count1ms+1
013E            182   
013E            183   Inc_Done:
013E            184            ; Check if half second has passed
013E E530       185            mov a, Count1ms+0
0140 B4F41C     186            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0143 E531       187            mov a, Count1ms+1
0145 B40117     188            cjne a, #high(500), Timer2_ISR_done
0148            189   
0148            190            ; 500 milliseconds have passed.  Set a flag so the main program knows
0148 D200       191            setb half_seconds_flag ; Let the main program know half second had passed
014A B28C       192            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
014C            193            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
014C E4         194            clr a
014D F530       195            mov Count1ms+0, a
014F F531       196            mov Count1ms+1, a
0151            197            ; Increment the BCD counter
0151 E532       198            mov a, BCD_counter
0153 309604     199            jnb UPDOWN, Timer2_ISR_decrement
0156 2401       200            add a, #0x01
0158 8002       201            sjmp Timer2_ISR_da
015A            202   Timer2_ISR_decrement:
015A 2499       203            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
015C            204   Timer2_ISR_da:
015C D4         205            da a ; Decimal adjust instruction.  Check datasheet for more details!
015D F532       206            mov BCD_counter, a
015F            207   
015F            208   Timer2_ISR_done:
015F D0D0       209            pop psw
0161 D0E0       210            pop acc
0163 32         211            reti
0164            212   
0164            213   ;---------------------------------;
0164            214   ; Main program. Includes hardware ;
0164            215   ; initialization and 'forever'    ;
0164            216   ; loop.                           ;
0164            217   ;---------------------------------;
0164            218   main:
0164            219            ; Initialization
0164 75817F     220       mov SP, #0x7F
0167 75B100     221       mov P0M1, #0x00
016A 75B200     222       mov P0M2, #0x00
016D 75B300     223       mov P1M1, #0x00
0170 75B400     224       mov P1M2, #0x00
0173 75AD00     225       mov P3M2, #0x00
0176 75AD00     226       mov P3M2, #0x00
0179            227   
0179 1200EE     228       lcall Timer0_Init
017C 120111     229       lcall Timer2_Init
017F D2AF       230       setb EA   ; Enable Global interrupts
0181 120087     231       lcall LCD_4BIT
0184            232       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
0184 C0E0       233            push acc
0186 7401       233            mov a, #1
0188 14         233            dec a
0189 1200C7     233            lcall ?Set_Cursor_1 ; Select column and row
018C D0E0       233            pop acc
018E C083       234            push dph
0190 C082       234            push dpl
0192 C0E0       234            push acc
0194 9000E2     234            mov dptr, #Initial_Message
0197 1200BA     234            lcall ?Send_Constant_String
019A D0E0       234            pop acc
019C D082       234            pop dpl
019E D083       234            pop dph
01A0 D200       235       setb half_seconds_flag
01A2 753200     236            mov BCD_counter, #0x00
01A5            237   
01A5            238            ; After initialization the program stays in this 'forever' loop
01A5            239   loop:
01A5 20951C     240            jb CLEAR_BUTTON, loop_a  ; if the 'CLEAR' button is not pressed skip
01A8 C002       241            push AR2
01AA 7A32       241            mov R2, #50
01AC 120038     241            lcall ?Wait_Milli_Seconds
01AF D002       241            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01B1 209510     242            jb CLEAR_BUTTON, loop_a  ; if the 'CLEAR' button is not pressed skip
01B4 3095FD     243            jnb CLEAR_BUTTON, $             ; Wait for button release.  The '$' means: jump to same instruction.
01B7            244            ; A valid press of the 'CLEAR' button has been detected, reset the BCD counter.
01B7            245            ; But first stop timer 2 and reset the milli-seconds counter, to resync everything.
01B7 C2CA       246            clr TR2                 ; Stop timer 2
01B9 E4         247            clr a
01BA F530       248            mov Count1ms+0, a
01BC F531       249            mov Count1ms+1, a
01BE            250            ; Now clear the BCD counter
01BE F532       251            mov BCD_counter, a
01C0 D2CA       252            setb TR2                ; Start timer 2
01C2 8003       253            sjmp loop_b             ; Display the new value
01C4            254   loop_a:
01C4 3000DE     255            jnb half_seconds_flag, loop
01C7            256   loop_b:
01C7            257       ;Using this to print the time
01C7 C200       258       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
01C9            259   ;        Set_Cursor(1, 14)     ; the place in the LCD where we want the BCD counter value
01C9            260   ;        Display_BCD(BCD_counter) ; This macro is also in 'LCD_4bit.inc'
01C9            261   
01C9 C0E0       262            push acc
01CB 7401       262            mov a, #1
01CD 14         262            dec a
01CE 1200C7     262            lcall ?Set_Cursor_1 ; Select column and row
01D1 D0E0       262            pop acc
01D3 C000       263            push ar0
01D5 A832       263            mov r0, BCD_counter
01D7 1200CC     263            lcall ?Display_BCD
01DA D000       263            pop ar0
01DC            264   
01DC C0E0       265            push acc
01DE 7404       265            mov a, #4
01E0 14         265            dec a
01E1 1200C7     265            lcall ?Set_Cursor_1 ; Select column and row
01E4 D0E0       265            pop acc
01E6 C000       266            push ar0
01E8 A832       266            mov r0, BCD_counter
01EA 1200CC     266            lcall ?Display_BCD
01ED D000       266            pop ar0
01EF            267   
01EF C0E0       268            push acc
01F1 7407       268            mov a, #7
01F3 14         268            dec a
01F4 1200C7     268            lcall ?Set_Cursor_1 ; Select column and row
01F7 D0E0       268            pop acc
01F9 C000       269            push ar0
01FB A832       269            mov r0, BCD_counter
01FD 1200CC     269            lcall ?Display_BCD
0200 D000       269            pop ar0
0202            270   
0202 C0E0       271            push acc
0204 740A       271            mov a, #10
0206 14         271            dec a
0207 1200C7     271            lcall ?Set_Cursor_1 ; Select column and row
020A D0E0       271            pop acc
020C C000       272            push ar0
020E A832       272            mov r0, BCD_counter
0210 1200CC     272            lcall ?Display_BCD
0213 D000       272            pop ar0
0215 0201A5     273       ljmp loop
0218            274   END
