0000              1   ; vim:foldmethod=marker:foldlevel=0
0000              2   
0000              3   ; DOCS {{{
0000              4   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              5   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P1.7 using
0000              6   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              7   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to
0000              8   ; zero if the 'CLEAR' push button connected to P1.5 is pressed.
                 10   $LIST
0000             12   
0000             13   ;  N76E003 pinout:
0000             14   ;                               -------
0000             15   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             16   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             17   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             18   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             19   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             20   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             21   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             22   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             23   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             24   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             25   ;                               -------
0000             26   ; 1     0.5 - BUTTON 1
0000             27   ; 2     USED
0000             28   ; 3     USED
0000             29   ; 4     RESET BUTTON
0000             30   ; 5     3.0 - BUTTON 2
0000             31   ; 6     SPEAKER
0000             32   ; 7     GND
0000             33   ; 8     1.6 - BUTTON 4
0000             34   ; 9     VDD
0000             35   ; 10    1.5 - BUTTON 5
0000             36   ;
0000             37   ; 11    UNUSED
0000             38   ; 12    USED
0000             39   ; 13    USED
0000             40   ; 14    1.1 - BUTTON 3
0000             41   ; 15    USED
0000             42   ; 16    UNUSED
0000             43   ; 17    UNUSED
0000             44   ; 18    UNUSED
0000             45   ; 19    UNUSED
0000             46   ; 20    UNUSED
0000             47   
0000             48   ; Button mapping:
0000             49   ; Button 1 to 5, starting from  left to right
0000             50   ; BUTTON 1 - HOUR
0000             51   ; BUTTON 2 - MIN
0000             52   ; BUTTON 3 - SEC
0000             53   ; BUTTON 4 - TIME SET
0000             54   ; BUTTON 5 - ALARM
0000             55   ; }}}
0000             56   ; CONFIG {{{
0000             57   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             58   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             59   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             60   TIMER2_RATE   EQU 500     ; 1000Hz, for a timer tick of 1ms
0000             61   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             62   
0000             63   UPDOWN        equ P1.6
0000             64   SOUND_OUT     equ P1.7
0000             65   BUTTON1       equ P0.5
0000             66   BUTTON2       equ P3.0
0000             67   BUTTON3       equ P1.1
0000             68   BUTTON4       equ P1.6
0000             69   BUTTON5       equ P1.5
0000             70   
0000             71   ; Reset vector
0000             72   org 0x0000
0000 02016A      73       ljmp main
0003             74   
0003             75   ; External interrupt 0 vector (not used in this code)
0003             76   org 0x0003
0003 32          77            reti
0004             78   
0004             79   ; Timer/Counter 0 overflow interrupt vector
000B             80   org 0x000B
000B 02010A      81            ljmp Timer0_ISR
000E             82   
000E             83   ; External interrupt 1 vector (not used in this code)
0013             84   org 0x0013
0013 32          85            reti
0014             86   
0014             87   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             88   org 0x001B
001B 32          89            reti
001C             90   
001C             91   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             92   org 0x0023
0023 32          93            reti
0024             94   
0024             95   ; Timer/Counter 2 overflow interrupt vector
002B             96   org 0x002B
002B 020134      97            ljmp Timer2_ISR
002E             98   
002E             99   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030            100   dseg at 0x30
0030            101   Count1ms:           ds 2 ; Used to determine when half second has passed
0032            102   BCD_counter:        ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            103   min_counter:        ds 1
0034            104   hour_counter:       ds 1
0035            105   day_state:          ds 1
0036            106   timesetseconds:     ds 1
0037            107   timesetminutes:     ds 1
0038            108   timesethours:       ds 1
0039            109   timesetdaystate:    ds 1
003A            110   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
003A            111   ; instructions with these variables.  This is how you define a 1-bit variable:
0000            112   bseg
0000            113   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001            114   
002E            115   cseg
002E            116   ; These 'equ' must match the hardware wiring
002E            117   LCD_RS equ P1.3
002E            118   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E            119   LCD_E  equ P1.4
002E            120   LCD_D4 equ P0.0
002E            121   LCD_D5 equ P0.1
002E            122   LCD_D6 equ P0.2
002E            123   LCD_D7 equ P0.3
002E            124   
                126   	$LIST
00E2            128   
00E2            129   ;                     1234567890123456    <- This helps determine the location of the counter
00E2 78783A78   130   Initial_Message:  db 'xx:xx:xx xx', 0
     783A7878
     20787800
00EE            131   ;                    '00:00:00 AM '
00EE 414D00     132   AM: db 'AM', 0
00F1 504D00     133   PM: db 'PM', 0
00F4            134   
00F4            135   ;---------------------------------;
00F4            136   ; Routine to initialize the ISR   ;
00F4            137   ; for timer 0                     ;
00F4            138   ;---------------------------------;
00F4            139   Timer0_Init:
00F4 438E08     140            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
00F7 E589       141            mov a, TMOD
00F9 54F0       142            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
00FB 4401       143            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
00FD F589       144            mov TMOD, a
00FF 758CF0     145            mov TH0, #high(TIMER0_RELOAD)
0102 758A2C     146            mov TL0, #low(TIMER0_RELOAD)
0105            147            ; Enable the timer and interrupts
0105 D2A9       148       setb ET0  ; Enable timer 0 interrupt
0107 D28C       149       setb TR0  ; Start timer 0
0109 22         150            ret
010A            151   
010A            152   ;---------------------------------;
010A            153   ; ISR for timer 0.  Set to execute;
010A            154   ; every 1/4096Hz to generate a    ;
010A            155   ; 2048 Hz wave at pin SOUND_OUT   ;
010A            156   ;---------------------------------;
010A            157   Timer0_ISR:
010A            158            ;clr TF0  ; According to the data sheet this is done for us already.
010A            159            ; Timer 0 doesn't have 16-bit auto-reload, so
010A C28C       160            clr TR0
010C 758CF0     161            mov TH0, #high(TIMER0_RELOAD)
010F 758A2C     162            mov TL0, #low(TIMER0_RELOAD)
0112 D28C       163            setb TR0
0114 B297       164            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
0116 32         165            reti
0117            166   
0117            167   ;---------------------------------;
0117            168   ; Routine to initialize the ISR   ;
0117            169   ; for timer 2                     ;
0117            170   ;---------------------------------;
0117            171   Timer2_Init:
0117 75C800     172            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
011A 75CD7E     173            mov TH2, #high(TIMER2_RELOAD)
011D 75CC50     174            mov TL2, #low(TIMER2_RELOAD)
0120            175            ; Set the reload value
0120 43C980     176            orl T2MOD, #0x80 ; Enable timer 2 autoreload
0123 75CB7E     177            mov RCMP2H, #high(TIMER2_RELOAD)
0126 75CA50     178            mov RCMP2L, #low(TIMER2_RELOAD)
0129            179            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0129 E4         180            clr a
012A F530       181            mov Count1ms+0, a
012C F531       182            mov Count1ms+1, a
012E            183            ; Enable the timer and interrupts
012E 439B80     184            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0131 D2CA       185       setb TR2  ; Enable timer 2
0133 22         186            ret
0134            187   
0134            188   ;---------------------------------;
0134            189   ; ISR for timer 2                 ;
0134            190   ;---------------------------------;
0134            191   Timer2_ISR:
0134 C2CF       192            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0136 B284       193            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0138            194   
0138            195            ; The two registers used in the ISR must be saved in the stack
0138 C0E0       196            push acc
013A C0D0       197            push psw
013C            198   
013C            199            ; Increment the 16-bit one mili second counter
013C 0530       200            inc Count1ms+0    ; Increment the low 8-bits first
013E E530       201            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0140 7002       202            jnz Inc_Done
0142 0531       203            inc Count1ms+1
0144            204   
0144            205   Inc_Done:
0144            206            ; Check if half second has passed
0144 E530       207            mov a, Count1ms+0
0146 B4F41C     208            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0149 E531       209            mov a, Count1ms+1
014B B40117     210            cjne a, #high(500), Timer2_ISR_done
014E            211   
014E            212            ; 500 milliseconds have passed.  Set a flag so the main program knows
014E D200       213            setb half_seconds_flag ; Let the main program know half second had passed
0150 B28C       214            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0152            215            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0152 E4         216            clr a
0153 F530       217            mov Count1ms+0, a
0155 F531       218            mov Count1ms+1, a
0157            219            ; Increment the BCD counter
0157 E532       220            mov a, BCD_counter
0159 309604     221            jnb UPDOWN, Timer2_ISR_decrement
015C 2401       222            add a, #0x01
015E 8002       223            sjmp Timer2_ISR_da
0160            224   Timer2_ISR_decrement:
0160 2499       225            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0162            226   Timer2_ISR_da:
0162 D4         227            da a ; Decimal adjust instruction.  Check datasheet for more details!
0163 F532       228            mov BCD_counter, a
0165            229   
0165            230   
0165 D0D0       231   Timer2_ISR_done: pop psw
0167 D0E0       232            pop acc
0169 32         233            reti
016A            234   ;}}}
016A            235   ; MAIN + BUTTONS {{{
016A            236   ;---------------------------------;
016A            237   ; Main program. Includes hardware ;
016A            238   ; initialization and 'forever'    ;
016A            239   ; loop.                           ;
016A            240   ;---------------------------------;
016A            241   main:
016A            242            ; Initialization
016A 75817F     243       mov SP, #0x7F
016D 75B100     244       mov P0M1, #0x00
0170 75B200     245       mov P0M2, #0x00
0173 75B300     246       mov P1M1, #0x00
0176 75B400     247       mov P1M2, #0x00
0179 75AD00     248       mov P3M2, #0x00
017C 75AD00     249       mov P3M2, #0x00
017F            250   
017F 1200F4     251       lcall Timer0_Init
0182 120117     252       lcall Timer2_Init
0185 D2AF       253       setb EA   ; Enable Global interrupts
0187 120087     254       lcall LCD_4BIT
018A            255       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
018A C0E0       256            push acc
018C 7401       256            mov a, #1
018E 14         256            dec a
018F 1200C7     256            lcall ?Set_Cursor_1 ; Select column and row
0192 D0E0       256            pop acc
0194 C083       257            push dph
0196 C082       257            push dpl
0198 C0E0       257            push acc
019A 9000E2     257            mov dptr, #Initial_Message
019D 1200BA     257            lcall ?Send_Constant_String
01A0 D0E0       257            pop acc
01A2 D082       257            pop dpl
01A4 D083       257            pop dph
01A6 D200       258       setb half_seconds_flag
01A8 753200     259            mov BCD_counter, #0x00
01AB 753300     260       mov min_counter, #0x00
01AE 753400     261       mov hour_counter, #0x00
01B1 753500     262       mov day_state, #0 ; To configure AM/PM
01B4 753600     263       mov timesetseconds, #0x00
01B7 753700     264       mov timesetminutes, #0x00
01BA 753800     265       mov timesethours, #0x00
01BD 753900     266       mov timesetdaystate, #0
01C0            267   
01C0            268            ; After initialization the program stays in this 'forever' loop
01C0            269   loop:
01C0 208511     270            jb BUTTON1, buttonjump2 ; if the 'CLEAR' button is not pressed skip
01C3 C002       271            push AR2
01C5 7A32       271            mov R2, #50
01C7 120038     271            lcall ?Wait_Milli_Seconds
01CA D002       271            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01CC 208505     272            jb BUTTON1, buttonjump2; if the 'CLEAR' button is not pressed skip
01CF 3085FD     273            jnb BUTTON1, $          ; Wait for button release.  The '$' means: jump to same instruction.
01D2 8051       274       sjmp clear
01D4            275   
01D4            276   buttonjump2:
01D4 20B011     277            jb BUTTON2, buttonjump3 ; if the 'CLEAR' button is not pressed skip
01D7 C002       278            push AR2
01D9 7A32       278            mov R2, #50
01DB 120038     278            lcall ?Wait_Milli_Seconds
01DE D002       278            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01E0 20B005     279            jb BUTTON2, buttonjump3; if the 'CLEAR' button is not pressed skip
01E3 30B0FD     280            jnb BUTTON2, $          ; Wait for button release.  The '$' means: jump to same instruction.
01E6 803D       281       sjmp clear
01E8            282   buttonjump3:
01E8 209111     283            jb BUTTON3, buttonjump4 ; if the 'CLEAR' button is not pressed skip
01EB C002       284            push AR2
01ED 7A32       284            mov R2, #50
01EF 120038     284            lcall ?Wait_Milli_Seconds
01F2 D002       284            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01F4 209105     285            jb BUTTON3, buttonjump4; if the 'CLEAR' button is not pressed skip
01F7 3091FD     286            jnb BUTTON3, $          ; Wait for button release.  The '$' means: jump to same instruction.
01FA 8029       287       sjmp clear
01FC            288   buttonjump4:
01FC 209612     289            jb BUTTON4, buttonjump5 ; if the 'CLEAR' button is not pressed skip
01FF C002       290            push AR2
0201 7A32       290            mov R2, #50
0203 120038     290            lcall ?Wait_Milli_Seconds
0206 D002       290            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0208 209606     291            jb BUTTON4, buttonjump5; if the 'CLEAR' button is not pressed skip
020B 3096FD     292            jnb BUTTON4, $          ; Wait for button release.  The '$' means: jump to same instruction.
020E 0202DD     293       ljmp displaytimesetfunction
0211            294   buttonjump5:
0211 20951F     295            jb BUTTON5, loop_a ; if the 'CLEAR' button is not pressed skip
0214 C002       296            push AR2
0216 7A32       296            mov R2, #50
0218 120038     296            lcall ?Wait_Milli_Seconds
021B D002       296            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
021D 209513     297            jb BUTTON5, loop_a  ; if the 'CLEAR' button is not pressed skip
0220 3095FD     298            jnb BUTTON5, $          ; Wait for button release.  The '$' means: jump to same instruction.
0223 8000       299       sjmp clear
0225            300   
0225            301   clear:
0225            302            ; A valid press of the 'CLEAR' button has been detected, reset the BCD counter.
0225            303            ; But first stop timer 2 and reset the milli-seconds counter, to resync everything.
0225 C2CA       304            clr TR2                 ; Stop timer 2
0227 E4         305            clr a
0228 F530       306            mov Count1ms+0, a
022A F531       307            mov Count1ms+1, a
022C            308            ; Now clear the BCD counter
022C F532       309            mov BCD_counter, a
022E D2CA       310            setb TR2                ; Start timer 2
0230            311       ;lcall loop_b
0230 0201C0     312       ljmp loop
0233            313   
0233            314   ;}}}
0233            315   ; LOOP B Display Timer {{{
0233            316   loop_a:
0233 30008A     317            jnb half_seconds_flag, loop
0236            318   loop_b:
0236            319       ;Using this to print the time
0236 C200       320       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
0238            321   ;        Set_Cursor(1, 14)     ; the place in the LCD where we want the BCD counter value
0238            322   ;        Display_BCD(BCD_counter) ; This macro is also in 'LCD_4bit.inc'
0238            323   
0238 AC32       324       mov R4, BCD_counter
023A BC0605     325       CJNE R4, #6, secondskip
023D 753200     326       mov BCD_counter, #0x00
0240 0533       327       inc min_counter
0242            328   secondskip:
0242 C0E0       329            push acc
0244 7407       329            mov a, #7
0246 14         329            dec a
0247 1200C7     329            lcall ?Set_Cursor_1 ; Select column and row
024A D0E0       329            pop acc
024C C000       330            push ar0
024E A832       330            mov r0, BCD_counter
0250 1200CC     330            lcall ?Display_BCD
0253 D000       330            pop ar0
0255            331   
0255 AC33       332       mov R4, min_counter
0257 BC0605     333       CJNE R4, #6, minskip
025A 753300     334       mov min_counter, #0x00
025D 0534       335       inc hour_counter
025F            336   minskip:
025F C0E0       337            push acc
0261 7404       337            mov a, #4
0263 14         337            dec a
0264 1200C7     337            lcall ?Set_Cursor_1 ; Select column and row
0267 D0E0       337            pop acc
0269 C000       338            push ar0
026B A833       338            mov r0, min_counter
026D 1200CC     338            lcall ?Display_BCD
0270 D000       338            pop ar0
0272            339   
0272 AC34       340       mov R4, hour_counter
0274 BC0C10     341       CJNE R4, #12, hourskip
0277 753400     342       mov hour_counter, #0x00
027A            343   ;Check states and run if else
027A AC35       344       mov R4, day_state
027C BC0005     345       cjne R4, #0, PMtoAM
027F            346   ;PMtoAM
027F 753501     347       mov day_state, #1
0282 8003       348       sjmp hourskip
0284            349   PMtoAM:
0284 753500     350       mov day_state, #0
0287            351   
0287            352   hourskip:
0287 C0E0       353            push acc
0289 7401       353            mov a, #1
028B 14         353            dec a
028C 1200C7     353            lcall ?Set_Cursor_1 ; Select column and row
028F D0E0       353            pop acc
0291 C000       354            push ar0
0293 A834       354            mov r0, hour_counter
0295 1200CC     354            lcall ?Display_BCD
0298 D000       354            pop ar0
029A            355   
029A            356   ;Check states and run alternate
029A AC35       357       mov R4, day_state
029C BC001F     358       CJNE R4, #0, timeAM
029F            359   timePM:
029F C0E0       360            push acc
02A1 740A       360            mov a, #10
02A3 14         360            dec a
02A4 1200C7     360            lcall ?Set_Cursor_1 ; Select column and row
02A7 D0E0       360            pop acc
02A9 C083       361            push dph
02AB C082       361            push dpl
02AD C0E0       361            push acc
02AF 9000F1     361            mov dptr, #PM
02B2 1200BA     361            lcall ?Send_Constant_String
02B5 D0E0       361            pop acc
02B7 D082       361            pop dpl
02B9 D083       361            pop dph
02BB 0201C0     362       ljmp loop
02BE            363   timeAM:
02BE C0E0       364            push acc
02C0 740A       364            mov a, #10
02C2 14         364            dec a
02C3 1200C7     364            lcall ?Set_Cursor_1 ; Select column and row
02C6 D0E0       364            pop acc
02C8            364   
02C8 C083       365            push dph
02CA C082       365            push dpl
02CC C0E0       365            push acc
02CE 9000EE     365            mov dptr, #AM
02D1 1200BA     365            lcall ?Send_Constant_String
02D4 D0E0       365            pop acc
02D6 D082       365            pop dpl
02D8 D083       365            pop dph
02DA 0201C0     366       ljmp loop
02DD            367   ;}}}
02DD            368   ; DISPLAY TIME FUNCTION {{{
02DD            369   displaytimesetfunction:
02DD            370   
02DD            371   loop2:
02DD 208513     372            jb BUTTON1, sbuttonjump2; if the 'CLEAR' button is not pressed skip
02E0 C002       373            push AR2
02E2 7A32       373            mov R2, #50
02E4 120038     373            lcall ?Wait_Milli_Seconds
02E7 D002       373            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
02E9 208507     374            jb BUTTON1, sbuttonjump2; if the 'CLEAR' button is not pressed skip
02EC 3085FD     375            jnb BUTTON1, $          ; Wait for button release.  The '$' means: jump to same instruction.
02EF 0534       376       inc hour_counter
02F1 8044       377       sjmp displaytimefunction
02F3            378   
02F3            379   sbuttonjump2:
02F3 20B013     380            jb BUTTON2, sbuttonjump3; if the 'CLEAR' button is not pressed skip
02F6 C002       381            push AR2
02F8 7AFF       381            mov R2, #255
02FA 120038     381            lcall ?Wait_Milli_Seconds
02FD D002       381            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
02FF 20B007     382            jb BUTTON2, sbuttonjump3; if the 'CLEAR' button is not pressed skip
0302 30B0FD     383            jnb BUTTON2, $          ; Wait for button release.  The '$' means: jump to same instruction.
0305 0533       384       inc min_counter
0307 802E       385       sjmp displaytimefunction
0309            386   sbuttonjump3:
0309 209113     387            jb BUTTON3, sbuttonjump4; if the 'CLEAR' button is not pressed skip
030C C002       388            push AR2
030E 7A32       388            mov R2, #50
0310 120038     388            lcall ?Wait_Milli_Seconds
0313 D002       388            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0315 209107     389            jb BUTTON3, sbuttonjump4; if the 'CLEAR' button is not pressed skip
0318 3091FD     390            jnb BUTTON3, $          ; Wait for button release.  The '$' means: jump to same instruction.
031B 0536       391       inc timesetseconds
031D 8018       392       sjmp displaytimefunction
031F            393   sbuttonjump4:
031F 209615     394            jb BUTTON4, displaytimefunction; if the 'CLEAR' button is not pressed skip
0322 C002       395            push AR2
0324 7A32       395            mov R2, #50
0326 120038     395            lcall ?Wait_Milli_Seconds
0329 D002       395            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
032B 209609     396            jb BUTTON4, displaytimefunction; if the 'CLEAR' button is not pressed skip
032E 3096FD     397            jnb BUTTON4, $          ; Wait for button release.  The '$' means: jump to same instruction.
0331 853632     398       mov BCD_counter, timesetseconds
0334 0201C0     399       ljmp loop
0337            400   
0337            401   displaytimefunction:
0337 AC36       402       mov R4, timesetseconds
0339 BC0603     403       CJNE R4, #6, ssecondskip
033C 753600     404       mov timesetseconds, #0x00
033F            405   ssecondskip:
033F C0E0       406            push acc
0341 7407       406            mov a, #7
0343 14         406            dec a
0344 1200C7     406            lcall ?Set_Cursor_1 ; Select column and row
0347 D0E0       406            pop acc
0349 C000       407            push ar0
034B A836       407            mov r0, timesetseconds
034D 1200CC     407            lcall ?Display_BCD
0350 D000       407            pop ar0
0352            408   
0352 AC33       409       mov R4, min_counter
0354 BC0603     410       CJNE R4, #6, sminskip
0357 753300     411       mov min_counter, #0x00
035A            412   sminskip:
035A C0E0       413            push acc
035C 7404       413            mov a, #4
035E 14         413            dec a
035F 1200C7     413            lcall ?Set_Cursor_1 ; Select column and row
0362 D0E0       413            pop acc
0364 C000       414            push ar0
0366 A833       414            mov r0, min_counter
0368 1200CC     414            lcall ?Display_BCD
036B D000       414            pop ar0
036D            415   
036D AC34       416       mov R4, hour_counter
036F BC0C10     417       CJNE R4, #12, shourskip
0372 753400     418       mov hour_counter, #0x00
0375            419   ;Check states and run if else
0375 AC35       420       mov R4, day_state
0377 BC0005     421       cjne R4, #0, sPMtoAM
037A            422   ;PMtoAM
037A 753501     423       mov day_state, #1
037D 8003       424       sjmp shourskip
037F            425   sPMtoAM:
037F 753500     426       mov day_state, #0
0382            427   
0382            428   shourskip:
0382 C0E0       429            push acc
0384 7401       429            mov a, #1
0386 14         429            dec a
0387 1200C7     429            lcall ?Set_Cursor_1 ; Select column and row
038A D0E0       429            pop acc
038C C000       430            push ar0
038E A834       430            mov r0, hour_counter
0390 1200CC     430            lcall ?Display_BCD
0393 D000       430            pop ar0
0395            431   
0395            432   ;Check states and run alternate
0395 AC35       433       mov R4, day_state
0397 BC001F     434       CJNE R4, #0, stimeAM
039A            435   stimePM:
039A C0E0       436            push acc
039C 740A       436            mov a, #10
039E 14         436            dec a
039F 1200C7     436            lcall ?Set_Cursor_1 ; Select column and row
03A2 D0E0       436            pop acc
03A4            436   
03A4 C083       437            push dph
03A6 C082       437            push dpl
03A8 C0E0       437            push acc
03AA 9000F1     437            mov dptr, #PM
03AD 1200BA     437            lcall ?Send_Constant_String
03B0 D0E0       437            pop acc
03B2 D082       437            pop dpl
03B4 D083       437            pop dph
03B6 0202DD     438       ljmp loop2
03B9            439   stimeAM:
03B9 C0E0       440            push acc
03BB 740A       440            mov a, #10
03BD 14         440            dec a
03BE 1200C7     440            lcall ?Set_Cursor_1 ; Select column and row
03C1 D0E0       440            pop acc
03C3            440   
03C3 C083       441            push dph
03C5 C082       441            push dpl
03C7 C0E0       441            push acc
03C9 9000EE     441            mov dptr, #AM
03CC 1200BA     441            lcall ?Send_Constant_String
03CF D0E0       441            pop acc
03D1 D082       441            pop dpl
03D3 D083       441            pop dph
03D5 0202DD     442       ljmp loop2
03D8            443   ;}}}
03D8            444   END
