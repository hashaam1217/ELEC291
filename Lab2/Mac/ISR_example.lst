0000              1   ; vim:foldmethod=marker:foldlevel=0
0000              2   
0000              3   ; DOCS {{{
0000              4   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              5   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P1.7 using
0000              6   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              7   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to
0000              8   ; zero if the 'CLEAR' push button connected to P1.5 is pressed.
                 10   $LIST
0000             12   
0000             13   ;  N76E003 pinout:
0000             14   ;                               -------
0000             15   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             16   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             17   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             18   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             19   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             20   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             21   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             22   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             23   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             24   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             25   ;                               -------
0000             26   ; 1     0.5 - BUTTON 1
0000             27   ; 2     USED
0000             28   ; 3     USED
0000             29   ; 4     RESET BUTTON
0000             30   ; 5     3.0 - BUTTON 2
0000             31   ; 6     SPEAKER
0000             32   ; 7     GND
0000             33   ; 8     1.6 - BUTTON 4
0000             34   ; 9     VDD
0000             35   ; 10    1.5 - BUTTON 5
0000             36   ;
0000             37   ; 11    UNUSED
0000             38   ; 12    USED
0000             39   ; 13    USED
0000             40   ; 14    1.1 - BUTTON 3
0000             41   ; 15    USED
0000             42   ; 16    UNUSED
0000             43   ; 17    UNUSED
0000             44   ; 18    UNUSED
0000             45   ; 19    UNUSED
0000             46   ; 20    UNUSED
0000             47   
0000             48   ; Button mapping:
0000             49   ; Button 1 to 5, starting from  left to right
0000             50   ; BUTTON 1 - HOUR
0000             51   ; BUTTON 2 - MIN
0000             52   ; BUTTON 3 - SEC
0000             53   ; BUTTON 4 - TIME SET
0000             54   ; BUTTON 5 - ALARM
0000             55   ; }}}
0000             56   ; CONFIG {{{
0000             57   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             58   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             59   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             60   TIMER2_RATE   EQU 500     ; 1000Hz, for a timer tick of 1ms
0000             61   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             62   
0000             63   UPDOWN        equ P1.6
0000             64   SOUND_OUT     equ P1.7
0000             65   BUTTON1       equ P0.5
0000             66   BUTTON2       equ P3.0
0000             67   BUTTON3       equ P1.1
0000             68   BUTTON4       equ P1.6
0000             69   BUTTON5       equ P1.5
0000             70   
0000             71   ; Reset vector
0000             72   org 0x0000
0000 02016A      73       ljmp main
0003             74   
0003             75   ; External interrupt 0 vector (not used in this code)
0003             76   org 0x0003
0003 32          77            reti
0004             78   
0004             79   ; Timer/Counter 0 overflow interrupt vector
000B             80   org 0x000B
000B 02010A      81            ljmp Timer0_ISR
000E             82   
000E             83   ; External interrupt 1 vector (not used in this code)
0013             84   org 0x0013
0013 32          85            reti
0014             86   
0014             87   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             88   org 0x001B
001B 32          89            reti
001C             90   
001C             91   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             92   org 0x0023
0023 32          93            reti
0024             94   
0024             95   ; Timer/Counter 2 overflow interrupt vector
002B             96   org 0x002B
002B 020134      97            ljmp Timer2_ISR
002E             98   
002E             99   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030            100   dseg at 0x30
0030            101   Count1ms:           ds 2 ; Used to determine when half second has passed
0032            102   BCD_counter:        ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033            103   min_counter:        ds 1
0034            104   hour_counter:       ds 1
0035            105   day_state:          ds 1
0036            106   timesetseconds:     ds 1
0037            107   timesetminutes:     ds 1
0038            108   timesethours:       ds 1
0039            109   timesetdaystate:    ds 1
003A            110   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
003A            111   ; instructions with these variables.  This is how you define a 1-bit variable:
0000            112   bseg
0000            113   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001            114   
002E            115   cseg
002E            116   ; These 'equ' must match the hardware wiring
002E            117   LCD_RS equ P1.3
002E            118   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E            119   LCD_E  equ P1.4
002E            120   LCD_D4 equ P0.0
002E            121   LCD_D5 equ P0.1
002E            122   LCD_D6 equ P0.2
002E            123   LCD_D7 equ P0.3
002E            124   
                126   	$LIST
00E2            128   
00E2            129   ;                     1234567890123456    <- This helps determine the location of the counter
00E2 78783A78   130   Initial_Message:  db 'xx:xx:xx xx', 0
     783A7878
     20787800
00EE            131   ;                    '00:00:00 AM '
00EE 414D00     132   AM: db 'AM', 0
00F1 504D00     133   PM: db 'PM', 0
00F4            134   
00F4            135   ;---------------------------------;
00F4            136   ; Routine to initialize the ISR   ;
00F4            137   ; for timer 0                     ;
00F4            138   ;---------------------------------;
00F4            139   Timer0_Init:
00F4 438E08     140            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
00F7 E589       141            mov a, TMOD
00F9 54F0       142            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
00FB 4401       143            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
00FD F589       144            mov TMOD, a
00FF 758CF0     145            mov TH0, #high(TIMER0_RELOAD)
0102 758A2C     146            mov TL0, #low(TIMER0_RELOAD)
0105            147            ; Enable the timer and interrupts
0105 D2A9       148       setb ET0  ; Enable timer 0 interrupt
0107 D28C       149       setb TR0  ; Start timer 0
0109 22         150            ret
010A            151   
010A            152   ;---------------------------------;
010A            153   ; ISR for timer 0.  Set to execute;
010A            154   ; every 1/4096Hz to generate a    ;
010A            155   ; 2048 Hz wave at pin SOUND_OUT   ;
010A            156   ;---------------------------------;
010A            157   Timer0_ISR:
010A            158            ;clr TF0  ; According to the data sheet this is done for us already.
010A            159            ; Timer 0 doesn't have 16-bit auto-reload, so
010A C28C       160            clr TR0
010C 758CF0     161            mov TH0, #high(TIMER0_RELOAD)
010F 758A2C     162            mov TL0, #low(TIMER0_RELOAD)
0112 D28C       163            setb TR0
0114 B297       164            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
0116 32         165            reti
0117            166   
0117            167   ;---------------------------------;
0117            168   ; Routine to initialize the ISR   ;
0117            169   ; for timer 2                     ;
0117            170   ;---------------------------------;
0117            171   Timer2_Init:
0117 75C800     172            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
011A 75CD7E     173            mov TH2, #high(TIMER2_RELOAD)
011D 75CC50     174            mov TL2, #low(TIMER2_RELOAD)
0120            175            ; Set the reload value
0120 43C980     176            orl T2MOD, #0x80 ; Enable timer 2 autoreload
0123 75CB7E     177            mov RCMP2H, #high(TIMER2_RELOAD)
0126 75CA50     178            mov RCMP2L, #low(TIMER2_RELOAD)
0129            179            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0129 E4         180            clr a
012A F530       181            mov Count1ms+0, a
012C F531       182            mov Count1ms+1, a
012E            183            ; Enable the timer and interrupts
012E 439B80     184            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0131 D2CA       185       setb TR2  ; Enable timer 2
0133 22         186            ret
0134            187   
0134            188   ;---------------------------------;
0134            189   ; ISR for timer 2                 ;
0134            190   ;---------------------------------;
0134            191   Timer2_ISR:
0134 C2CF       192            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0136 B284       193            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0138            194   
0138            195            ; The two registers used in the ISR must be saved in the stack
0138 C0E0       196            push acc
013A C0D0       197            push psw
013C            198   
013C            199            ; Increment the 16-bit one mili second counter
013C 0530       200            inc Count1ms+0    ; Increment the low 8-bits first
013E E530       201            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0140 7002       202            jnz Inc_Done
0142 0531       203            inc Count1ms+1
0144            204   
0144            205   Inc_Done:
0144            206            ; Check if half second has passed
0144 E530       207            mov a, Count1ms+0
0146 B4F41C     208            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0149 E531       209            mov a, Count1ms+1
014B B40117     210            cjne a, #high(500), Timer2_ISR_done
014E            211   
014E            212            ; 500 milliseconds have passed.  Set a flag so the main program knows
014E D200       213            setb half_seconds_flag ; Let the main program know half second had passed
0150 B28C       214            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0152            215            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0152 E4         216            clr a
0153 F530       217            mov Count1ms+0, a
0155 F531       218            mov Count1ms+1, a
0157            219            ; Increment the BCD counter
0157 E532       220            mov a, BCD_counter
0159 309604     221            jnb UPDOWN, Timer2_ISR_decrement
015C 2401       222            add a, #0x01
015E 8002       223            sjmp Timer2_ISR_da
0160            224   Timer2_ISR_decrement:
0160 2499       225            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0162            226   Timer2_ISR_da:
0162 D4         227            da a ; Decimal adjust instruction.  Check datasheet for more details!
0163 F532       228            mov BCD_counter, a
0165            229   
0165            230   
0165 D0D0       231   Timer2_ISR_done: pop psw
0167 D0E0       232            pop acc
0169 32         233            reti
016A            234   ;}}}
016A            235   ; MAIN + BUTTONS {{{
016A            236   ;---------------------------------;
016A            237   ; Main program. Includes hardware ;
016A            238   ; initialization and 'forever'    ;
016A            239   ; loop.                           ;
016A            240   ;---------------------------------;
016A            241   main:
016A            242            ; Initialization
016A 75817F     243       mov SP, #0x7F
016D 75B100     244       mov P0M1, #0x00
0170 75B200     245       mov P0M2, #0x00
0173 75B300     246       mov P1M1, #0x00
0176 75B400     247       mov P1M2, #0x00
0179 75AD00     248       mov P3M2, #0x00
017C 75AD00     249       mov P3M2, #0x00
017F            250   
017F 1200F4     251       lcall Timer0_Init
0182 120117     252       lcall Timer2_Init
0185 D2AF       253       setb EA   ; Enable Global interrupts
0187 120087     254       lcall LCD_4BIT
018A            255       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
018A C0E0       256            push acc
018C 7401       256            mov a, #1
018E 14         256            dec a
018F 1200C7     256            lcall ?Set_Cursor_1 ; Select column and row
0192 D0E0       256            pop acc
0194 C083       257            push dph
0196 C082       257            push dpl
0198 C0E0       257            push acc
019A 9000E2     257            mov dptr, #Initial_Message
019D 1200BA     257            lcall ?Send_Constant_String
01A0 D0E0       257            pop acc
01A2 D082       257            pop dpl
01A4 D083       257            pop dph
01A6 D200       258       setb half_seconds_flag
01A8 753200     259            mov BCD_counter, #0x00
01AB 753300     260       mov min_counter, #0x00
01AE 753400     261       mov hour_counter, #0x00
01B1 753500     262       mov day_state, #0 ; To configure AM/PM
01B4 753600     263       mov timesetseconds, #0x00
01B7 753700     264       mov timesetminutes, #0x00
01BA 753800     265       mov timesethours, #0x00
01BD 753900     266       mov timesetdaystate, #0
01C0            267   
01C0            268            ; After initialization the program stays in this 'forever' loop
01C0            269   loop:
01C0 208511     270            jb BUTTON1, buttonjump2 ; if the 'CLEAR' button is not pressed skip
01C3 C002       271            push AR2
01C5 7A32       271            mov R2, #50
01C7 120038     271            lcall ?Wait_Milli_Seconds
01CA D002       271            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01CC 208505     272            jb BUTTON1, buttonjump2; if the 'CLEAR' button is not pressed skip
01CF 3085FD     273            jnb BUTTON1, $          ; Wait for button release.  The '$' means: jump to same instruction.
01D2 8051       274       sjmp clear
01D4            275   
01D4            276   buttonjump2:
01D4 20B011     277            jb BUTTON2, buttonjump3 ; if the 'CLEAR' button is not pressed skip
01D7 C002       278            push AR2
01D9 7A32       278            mov R2, #50
01DB 120038     278            lcall ?Wait_Milli_Seconds
01DE D002       278            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01E0 20B005     279            jb BUTTON2, buttonjump3; if the 'CLEAR' button is not pressed skip
01E3 30B0FD     280            jnb BUTTON2, $          ; Wait for button release.  The '$' means: jump to same instruction.
01E6 803D       281       sjmp clear
01E8            282   buttonjump3:
01E8 209111     283            jb BUTTON3, buttonjump4 ; if the 'CLEAR' button is not pressed skip
01EB C002       284            push AR2
01ED 7A32       284            mov R2, #50
01EF 120038     284            lcall ?Wait_Milli_Seconds
01F2 D002       284            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01F4 209105     285            jb BUTTON3, buttonjump4; if the 'CLEAR' button is not pressed skip
01F7 3091FD     286            jnb BUTTON3, $          ; Wait for button release.  The '$' means: jump to same instruction.
01FA 8029       287       sjmp clear
01FC            288   buttonjump4:
01FC 209614     289            jb BUTTON4, buttonjump5 ; if the 'CLEAR' button is not pressed skip
01FF C002       290            push AR2
0201 7A32       290            mov R2, #50
0203 120038     290            lcall ?Wait_Milli_Seconds
0206 D002       290            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0208 209608     291            jb BUTTON4, buttonjump5; if the 'CLEAR' button is not pressed skip
020B 3096FD     292            jnb BUTTON4, $          ; Wait for button release.  The '$' means: jump to same instruction.
020E 1202DC     293       lcall displaytimesetfunction
0211 80AD       294       sjmp loop
0213            295   buttonjump5:
0213 20951C     296            jb BUTTON5, loop_a ; if the 'CLEAR' button is not pressed skip
0216 C002       297            push AR2
0218 7A32       297            mov R2, #50
021A 120038     297            lcall ?Wait_Milli_Seconds
021D D002       297            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
021F 209510     298            jb BUTTON5, loop_a  ; if the 'CLEAR' button is not pressed skip
0222 3095FD     299            jnb BUTTON5, $          ; Wait for button release.  The '$' means: jump to same instruction.
0225            300   
0225            301   clear:
0225            302   
0225            303   
0225            304   
0225            305   
0225            306            ; A valid press of the 'CLEAR' button has been detected, reset the BCD counter.
0225            307            ; But first stop timer 2 and reset the milli-seconds counter, to resync everything.
0225 C2CA       308            clr TR2                 ; Stop timer 2
0227 E4         309            clr a
0228 F530       310            mov Count1ms+0, a
022A F531       311            mov Count1ms+1, a
022C            312            ; Now clear the BCD counter
022C F532       313            mov BCD_counter, a
022E D2CA       314            setb TR2                ; Start timer 2
0230 8003       315       sjmp loop_b
0232            316       ;ljmp loop
0232            317   
0232            318   ;}}}
0232            319   ; LOOP B Display Timer {{{
0232            320   loop_a:
0232 30008B     321            jnb half_seconds_flag, loop
0235            322   loop_b:
0235            323       ;Using this to print the time
0235 C200       324       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
0237            325   ;        Set_Cursor(1, 14)     ; the place in the LCD where we want the BCD counter value
0237            326   ;        Display_BCD(BCD_counter) ; This macro is also in 'LCD_4bit.inc'
0237            327   
0237 AC32       328       mov R4, BCD_counter
0239 BC3C05     329       CJNE R4, #60, secondskip
023C 753200     330       mov BCD_counter, #0x00
023F 0533       331       inc min_counter
0241            332   secondskip:
0241 C0E0       333            push acc
0243 7407       333            mov a, #7
0245 14         333            dec a
0246 1200C7     333            lcall ?Set_Cursor_1 ; Select column and row
0249 D0E0       333            pop acc
024B C000       334            push ar0
024D A832       334            mov r0, BCD_counter
024F 1200CC     334            lcall ?Display_BCD
0252 D000       334            pop ar0
0254            335   
0254 AC33       336       mov R4, min_counter
0256 BC3C05     337       CJNE R4, #60, minskip
0259 753300     338       mov min_counter, #0x00
025C 0534       339       inc hour_counter
025E            340   minskip:
025E C0E0       341            push acc
0260 7404       341            mov a, #4
0262 14         341            dec a
0263 1200C7     341            lcall ?Set_Cursor_1 ; Select column and row
0266 D0E0       341            pop acc
0268 C000       342            push ar0
026A A833       342            mov r0, min_counter
026C 1200CC     342            lcall ?Display_BCD
026F D000       342            pop ar0
0271            343   
0271 AC34       344       mov R4, hour_counter
0273 BC0C10     345       CJNE R4, #12, hourskip
0276 753400     346       mov hour_counter, #0x00
0279            347   ;Check states and run if else
0279 AC35       348       mov R4, day_state
027B BC0005     349       cjne R4, #0, PMtoAM
027E            350   ;PMtoAM
027E 753501     351       mov day_state, #1
0281 8003       352       sjmp hourskip
0283            353   PMtoAM:
0283 753500     354       mov day_state, #0
0286            355   
0286            356   hourskip:
0286 C0E0       357            push acc
0288 7401       357            mov a, #1
028A 14         357            dec a
028B 1200C7     357            lcall ?Set_Cursor_1 ; Select column and row
028E D0E0       357            pop acc
0290 C000       358            push ar0
0292 A834       358            mov r0, hour_counter
0294 1200CC     358            lcall ?Display_BCD
0297 D000       358            pop ar0
0299            359   
0299            360   ;Check states and run alternate
0299 AC35       361       mov R4, day_state
029B BC001F     362       CJNE R4, #0, timeAM
029E            363   timePM:
029E C0E0       364            push acc
02A0 740A       364            mov a, #10
02A2 14         364            dec a
02A3 1200C7     364            lcall ?Set_Cursor_1 ; Select column and row
02A6 D0E0       364            pop acc
02A8 C083       365            push dph
02AA C082       365            push dpl
02AC C0E0       365            push acc
02AE 9000F1     365            mov dptr, #PM
02B1 1200BA     365            lcall ?Send_Constant_String
02B4 D0E0       365            pop acc
02B6 D082       365            pop dpl
02B8 D083       365            pop dph
02BA 0201C0     366       ljmp loop
02BD            367   timeAM:
02BD C0E0       368            push acc
02BF 740A       368            mov a, #10
02C1 14         368            dec a
02C2 1200C7     368            lcall ?Set_Cursor_1 ; Select column and row
02C5 D0E0       368            pop acc
02C7            368   
02C7 C083       369            push dph
02C9 C082       369            push dpl
02CB C0E0       369            push acc
02CD 9000EE     369            mov dptr, #AM
02D0 1200BA     369            lcall ?Send_Constant_String
02D3 D0E0       369            pop acc
02D5 D082       369            pop dpl
02D7 D083       369            pop dph
02D9 0201C0     370       ljmp loop
02DC            371   ;}}}
02DC            372   ; DISPLAY TIME FUNCTION {{{
02DC            373   displaytimesetfunction:
02DC            374   
02DC            375   loop2:
02DC 208513     376            jb BUTTON1, sbuttonjump2 ; if the 'CLEAR' button is not pressed skip
02DF C002       377            push AR2
02E1 7A32       377            mov R2, #50
02E3 120038     377            lcall ?Wait_Milli_Seconds
02E6 D002       377            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
02E8 208507     378            jb BUTTON1, sbuttonjump2; if the 'CLEAR' button is not pressed skip
02EB 3085FD     379            jnb BUTTON1, $          ; Wait for button release.  The '$' means: jump to same instruction.
02EE 0538       380       inc timesethours
02F0 803D       381       sjmp displaytimefunction
02F2            382   
02F2            383   sbuttonjump2:
02F2 20B011     384            jb BUTTON2, sbuttonjump3 ; if the 'CLEAR' button is not pressed skip
02F5 C002       385            push AR2
02F7 7A64       385            mov R2, #100
02F9 120038     385            lcall ?Wait_Milli_Seconds
02FC D002       385            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
02FE 20B005     386            jb BUTTON2, sbuttonjump3; if the 'CLEAR' button is not pressed skip
0301 30B0FD     387            jnb BUTTON2, $          ; Wait for button release.  The '$' means: jump to same instruction.
0304            388       ;inc timesetminutes
0304 8029       389       sjmp displaytimefunction
0306            390   sbuttonjump3:
0306 209113     391            jb BUTTON3, sbuttonjump4 ; if the 'CLEAR' button is not pressed skip
0309 C002       392            push AR2
030B 7A64       392            mov R2, #100
030D 120038     392            lcall ?Wait_Milli_Seconds
0310 D002       392            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0312 209107     393            jb BUTTON3, sbuttonjump4; if the 'CLEAR' button is not pressed skip
0315 3091FD     394            jnb BUTTON3, $          ; Wait for button release.  The '$' means: jump to same instruction.
0318 0536       395       inc timesetseconds
031A 8013       396       sjmp displaytimefunction
031C            397   sbuttonjump4:
031C 209610     398            jb BUTTON4, displaytimefunction; if the 'CLEAR' button is not pressed skip
031F C002       399            push AR2
0321 7A64       399            mov R2, #100
0323 120038     399            lcall ?Wait_Milli_Seconds
0326 D002       399            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0328 209604     400            jb BUTTON4, displaytimefunction; if the 'CLEAR' button is not pressed skip
032B 3096FD     401            jnb BUTTON4, $          ; Wait for button release.  The '$' me2buttans: jump to same instruction.
032E 22         402       ret
032F            403   
032F            404   
032F            405   displaytimefunction:
032F AC36       406       mov R4, timesetseconds
0331 BC0605     407       CJNE R4, #6, timesetsecondskip
0334 753600     408       mov timesetseconds, #0x00
0337 0537       409       inc timesetminutes
0339            410   timesetsecondskip:
0339 C0E0       411            push acc
033B 7407       411            mov a, #7
033D 14         411            dec a
033E 1200C7     411            lcall ?Set_Cursor_1 ; Select column and row
0341 D0E0       411            pop acc
0343 E536       412       mov a, timesetseconds
0345 D4         413       da a
0346 F536       414       mov timesetseconds, a
0348 C000       415            push ar0
034A A836       415            mov r0, timesetseconds
034C 1200CC     415            lcall ?Display_BCD
034F D000       415            pop ar0
0351            416   
0351 AC37       417       mov R4, timesetminutes
0353 BC0605     418       CJNE R4, #6, timesetminskip
0356 753700     419       mov timesetminutes, #0x00
0359 0538       420       inc timesethours
035B            421   timesetminskip:
035B C0E0       422            push acc
035D 7404       422            mov a, #4
035F 14         422            dec a
0360 1200C7     422            lcall ?Set_Cursor_1 ; Select column and row
0363 D0E0       422            pop acc
0365 E537       423       mov a, timesetminutes
0367 D4         424       da a
0368 F537       425       mov timesetminutes, a
036A C000       426            push ar0
036C A837       426            mov r0, timesetminutes
036E 1200CC     426            lcall ?Display_BCD
0371 D000       426            pop ar0
0373            427   
0373 AC38       428       mov R4, timesethours
0375 BC0C10     429       CJNE R4, #12, timesethourskip
0378 753800     430       mov timesethours, #0x00
037B            431   ;Check states and run if else
037B AC39       432       mov R4, timesetdaystate
037D BC0005     433       cjne R4, #0, setPMtoAM
0380            434   ;PMtoAM
0380 753901     435       mov timesetdaystate, #1
0383 8003       436       sjmp timesethourskip
0385            437   setPMtoAM:
0385 753900     438       mov timesetdaystate, #0
0388            439   
0388            440   timesethourskip:
0388 C0E0       441            push acc
038A 7401       441            mov a, #1
038C 14         441            dec a
038D 1200C7     441            lcall ?Set_Cursor_1 ; Select column and row
0390 D0E0       441            pop acc
0392 E538       442       mov a, timesethours
0394 D4         443       da a
0395 F538       444       mov timesethours, a
0397 C000       445            push ar0
0399 A838       445            mov r0, timesethours
039B 1200CC     445            lcall ?Display_BCD
039E D000       445            pop ar0
03A0            446   
03A0            447   ;Check states and run alternate
03A0 AC39       448       mov R4, timesetdaystate
03A2 BC001F     449       CJNE R4, #0, settimeAM
03A5            450   settimePM:
03A5 C0E0       451            push acc
03A7 740A       451            mov a, #10
03A9 14         451            dec a
03AA 1200C7     451            lcall ?Set_Cursor_1 ; Select column and row
03AD D0E0       451            pop acc
03AF            451   
03AF C083       452            push dph
03B1 C082       452            push dpl
03B3 C0E0       452            push acc
03B5 9000F1     452            mov dptr, #PM
03B8 1200BA     452            lcall ?Send_Constant_String
03BB D0E0       452            pop acc
03BD D082       452            pop dpl
03BF D083       452            pop dph
03C1 0202DC     453       ljmp loop2
03C4            454   settimeAM:
03C4 C0E0       455            push acc
03C6 740A       455            mov a, #10
03C8 14         455            dec a
03C9 1200C7     455            lcall ?Set_Cursor_1 ; Select column and row
03CC D0E0       455            pop acc
03CE            455   
03CE C083       456            push dph
03D0 C082       456            push dpl
03D2 C0E0       456            push acc
03D4 9000EE     456            mov dptr, #AM
03D7 1200BA     456            lcall ?Send_Constant_String
03DA D0E0       456            pop acc
03DC D082       456            pop dpl
03DE D083       456            pop dph
03E0 0202DC     457       ljmp loop2
03E3            458   ;}}}
03E3            459   END
