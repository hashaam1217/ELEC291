0000              1   ; 76E003 ADC test program: Reads channel 7 on P1.1, pin 14
0000              2   ; This version uses an LED as voltage reference connected to pin 6 (P1.7/AIN0)
0000              3   
                  5   $LIST
0000              7   
0000              8   ;  N76E003 pinout:
0000              9   ;                               -------
0000             10   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             11   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             12   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             13   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             14   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             15   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             16   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             17   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             18   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             19   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             20   ;                               -------
0000             21   ;
0000             22   
0000             23   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             24   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             25   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             26   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             27   
0000             28   ORG 0x0000
0000 020493      29            ljmp main
0003             30   
0003             31   ;                     1234567890123456    <- This helps determine the location of the counter
0003 2A2A2A20    32   test_message:     db '*** ADC TEST ***', 0
     41444320
     54455354
     202A2A2A
     00
0014 56287069    33   value_message:    db 'V(pin 14)=      ', 0
     6E203134
     293D2020
     20202020
     00
0025             34   cseg
0025             35   ; These 'equ' must match the hardware wiring
0025             36   LCD_RS equ P1.3
0025             37   LCD_E  equ P1.4
0025             38   LCD_D4 equ P0.0
0025             39   LCD_D5 equ P0.1
0025             40   LCD_D6 equ P0.2
0025             41   LCD_D7 equ P0.3
0025             42   
                 45   $LIST
012B             47   
012B             48   ; These register definitions needed by 'math32.inc'
0030             49   DSEG at 30H
0030             50   x:   ds 4
0034             51   y:   ds 4
0038             52   bcd: ds 5
003D             53   VLED_ADC: ds 2
003F             54   
0000             55   BSEG
0000             56   mf: dbit 1
0001             57   
                546   $LIST
                 59   $LIST
039B             61   
039B             62   Init_All:
039B             63            ; Configure all the pins for biderectional I/O
039B 75AC00      64            mov     P3M1, #0x00
039E 75AD00      65            mov     P3M2, #0x00
03A1 75B300      66            mov     P1M1, #0x00
03A4 75B400      67            mov     P1M2, #0x00
03A7 75B100      68            mov     P0M1, #0x00
03AA 75B200      69            mov     P0M2, #0x00
03AD             70   
03AD 438E10      71            orl     CKCON, #0x10 ; CLK is the input for timer 1
03B0 438780      72            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
03B3 759852      73            mov     SCON, #0x52
03B6 53C4DF      74            anl     T3CON, #0b11011111
03B9 53890F      75            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
03BC 438920      76            orl     TMOD, #0x20 ; Timer 1 Mode 2
03BF 758DF7      77            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
03C2 D28E        78            setb TR1
03C4             79   
03C4             80            ; Using timer 0 for delay functions.  Initialize here:
03C4 C28C        81            clr     TR0 ; Stop timer 0
03C6 438E08      82            orl     CKCON,#0x08 ; CLK is the input for timer 0
03C9 5389F0      83            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
03CC 438901      84            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
03CF             85   
03CF             86            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
03CF 43B382      87            orl     P1M1, #0b10000010
03D2 53B47D      88            anl     P1M2, #0b01111101
03D5             89   
03D5             90            ; Initialize and start the ADC:
03D5 53E8F0      91            anl ADCCON0, #0xF0
03D8 43E807      92            orl ADCCON0, #0x07 ; Select channel 7
03DB             93            ; AINDIDS select if some pins are analog inputs or digital I/O:
03DB 75F600      94            mov AINDIDS, #0x00 ; Disable all analog inputs
03DE 43F681      95            orl AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
03E1 43E101      96            orl ADCCON1, #0x01 ; Enable ADC
03E4             97   
03E4 22          98            ret
03E5             99   
03E5            100   wait_1ms:
03E5 C28C       101            clr     TR0 ; Stop timer 0
03E7 C28D       102            clr     TF0 ; Clear overflow flag
03E9 758CBF     103            mov     TH0, #high(TIMER0_RELOAD_1MS)
03EC 758A28     104            mov     TL0,#low(TIMER0_RELOAD_1MS)
03EF D28C       105            setb TR0
03F1 308DFD     106            jnb     TF0, $ ; Wait for overflow
03F4 22         107            ret
03F5            108   
03F5            109   ; Wait the number of miliseconds in R2
03F5            110   waitms:
03F5 1203E5     111            lcall wait_1ms
03F8 DAFB       112            djnz R2, waitms
03FA 22         113            ret
03FB            114   
03FB            115   ; We can display a number any way we want.  In this case with
03FB            116   ; four decimal places.
03FB            117   Display_formated_BCD:
03FB C0E0       118            push acc
03FD 740A       118            mov a, #10
03FF 14         118            dec a
0400 1200BC     118            lcall ?Set_Cursor_2 ; Select column and row
0403 D0E0       118            pop acc
0405 C000       119            push ar0
0407 A83A       119            mov r0, bcd+2
0409 1200C3     119            lcall ?Display_BCD
040C D000       119            pop ar0
040E C0E0       120            push acc
0410 742E       120            mov a, #'.'
0412 120074     120            lcall ?WriteData
0415 D0E0       120            pop acc
0417 C000       121            push ar0
0419 A839       121            mov r0, bcd+1
041B 1200C3     121            lcall ?Display_BCD
041E D000       121            pop ar0
0420 C000       122            push ar0
0422 A838       122            mov r0, bcd+0
0424 1200C3     122            lcall ?Display_BCD
0427 D000       122            pop ar0
0429 C0E0       123            push acc
042B 740A       123            mov a, #10
042D 14         123            dec a
042E 1200BC     123            lcall ?Set_Cursor_2 ; Select column and row
0431 D0E0       123            pop acc
0433 C0E0       124            push acc
0435 743D       124            mov a, #'='
0437 120074     124            lcall ?WriteData
043A D0E0       124            pop acc
043C 22         125            ret
043D            126   
043D            127   Read_ADC:
043D C2EF       128            clr ADCF
043F D2EE       129            setb ADCS ;  ADC start trigger signal
0441 30EFFD     130       jnb ADCF, $ ; Wait for conversion complete
0444            131   
0444            132       ; Read the ADC result and store in [R1, R0]
0444 E5C2       133       mov a, ADCRL
0446 540F       134       anl a, #0x0f
0448 F8         135       mov R0, a
0449 E5C3       136       mov a, ADCRH
044B C4         137       swap a
044C C0E0       138       push acc
044E 540F       139       anl a, #0x0f
0450 F9         140       mov R1, a
0451 D0E0       141       pop acc
0453 54F0       142       anl a, #0xf0
0455 48         143       orl a, R0
0456 F8         144       mov R0, A
0457 22         145            ret
0458            146   
0458            147   ; Custom functions:
                148   Send_BCD mac
                149   push ar0
                150   mov r0, %0
                151   lcall ?Send_BCD
                152   pop ar0
                153   endmac
0458            154   ?Send_BCD:
0458 C0E0       155   push acc
045A            156   ; Write most significant digit
045A E8         157   mov a, r0
045B C4         158   swap a
045C 540F       159   anl a, #0fh
045E 4430       160   orl a, #30h
0460 12010B     161   lcall putchar
0463            162   ; write least significant digit
0463 E8         163   mov a, r0
0464 540F       164   anl a, #0fh
0466 4430       165   orl a, #30h
0468 12010B     166   lcall putchar
046B D0E0       167   pop acc
046D 22         168   ret
046E            169   
046E            170   SendtoSerial:
046E C000       171   push ar0
0470 A83B       171   mov r0, bcd + 3
0472 120458     171   lcall ?Send_BCD
0475 D000       171   pop ar0
0477 C000       172   push ar0
0479 A83A       172   mov r0, bcd + 2
047B 120458     172   lcall ?Send_BCD
047E D000       172   pop ar0
0480 C000       173   push ar0
0482 A839       173   mov r0, bcd + 1
0484 120458     173   lcall ?Send_BCD
0487 D000       173   pop ar0
0489 C000       174   push ar0
048B A838       174   mov r0, bcd + 0
048D 120458     174   lcall ?Send_BCD
0490 D000       174   pop ar0
0492            175   
0492 22         176       ret
0493            177   
0493            178   
0493            179   main:
0493 75817F     180            mov sp, #0x7f
0496 12039B     181            lcall Init_All
0499 12007E     182       lcall LCD_4BIT
049C            183   
049C            184       ; initial messages in LCD
049C C0E0       185            push acc
049E 7401       185            mov a, #1
04A0 14         185            dec a
04A1 1200BE     185            lcall ?Set_Cursor_1 ; Select column and row
04A4 D0E0       185            pop acc
04A6 C083       186            push dph
04A8 C082       186            push dpl
04AA C0E0       186            push acc
04AC 900003     186            mov dptr, #test_message
04AF 1200B1     186            lcall ?Send_Constant_String
04B2 D0E0       186            pop acc
04B4 D082       186            pop dpl
04B6 D083       186            pop dph
04B8 C0E0       187            push acc
04BA 7401       187            mov a, #1
04BC 14         187            dec a
04BD 1200BC     187            lcall ?Set_Cursor_2 ; Select column and row
04C0 D0E0       187            pop acc
04C2 C083       188            push dph
04C4 C082       188            push dpl
04C6 C0E0       188            push acc
04C8 900014     188            mov dptr, #value_message
04CB 1200B1     188            lcall ?Send_Constant_String
04CE D0E0       188            pop acc
04D0 D082       188            pop dpl
04D2 D083       188            pop dph
04D4            189   
04D4            190   Forever:
04D4            191   
04D4            192            ; Read the 2.08V LED voltage connected to AIN0 on pin 6
04D4 53E8F0     193            anl ADCCON0, #0xF0
04D7 43E800     194            orl ADCCON0, #0x00 ; Select channel 0
04DA            195   
04DA 12043D     196            lcall Read_ADC
04DD            197            ; Save result for later use
04DD 883D       198            mov VLED_ADC+0, R0
04DF 893E       199            mov VLED_ADC+1, R1
04E1            200   
04E1            201            ; Read the signal connected to AIN7
04E1 53E8F0     202            anl ADCCON0, #0xF0
04E4 43E807     203            orl ADCCON0, #0x07 ; Select channel 7
04E7 12043D     204            lcall Read_ADC
04EA            205   
04EA            206       ; Convert to voltage
04EA 8830       207            mov x+0, R0
04EC 8931       208            mov x+1, R1
04EE            209            ; Pad other bits with zero
04EE 753200     210            mov x+2, #0
04F1 753300     211            mov x+3, #0
04F4 753453     212            mov y+0, #low (20563 % 0x10000)
04F7 753550     212            mov y+1, #high(20563 % 0x10000)
04FA 753600     212            mov y+2, #low (20563 / 0x10000)
04FD 753700     212            mov y+3, #high(20563 / 0x10000) ; The MEASURED LED voltage: 2.074V, with 4 decimal places
0500 1202A5     213            lcall mul32
0503            214            ; Retrive the ADC LED value
0503 853D34     215            mov y+0, VLED_ADC+0
0506 853E35     216            mov y+1, VLED_ADC+1
0509            217            ; Pad other bits with zero
0509 753600     218            mov y+2, #0
050C 753700     219            mov y+3, #0
050F 120332     220            lcall div32
0512            221   
0512            222            ; Convert to BCD and display
0512 12012B     223            lcall hex2bcd
0515 1203FB     224            lcall Display_formated_BCD
0518 E538       225       mov a, bcd
051A 12046E     226       lcall SendtoSerial
051D 120121     227       lcall MainProgram
0520            228   
0520            229            ; Wait 500 ms between conversions
0520 7AFA       230            mov R2, #250
0522 1203F5     231            lcall waitms
0525 7AFA       232            mov R2, #250
0527 1203F5     233            lcall waitms
052A            234   
052A 0204D4     235            ljmp Forever
052D            236   END
